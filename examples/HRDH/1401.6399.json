[
    {
        "text": "SIMD Compression and the Intersection",
        "box": [
            173,
            110,
            419,
            125
        ],
        "class": "title",
        "page": 0,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "of Sorted Integers",
        "box": [
            242,
            126,
            351,
            141
        ],
        "class": "title",
        "page": 0,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. Lemire1 *, L. Boytsov2, N. Kurz3",
        "box": [
            214,
            166,
            378,
            179
        ],
        "class": "author",
        "page": 0,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "1LICEF Research Center, TELUQ, Montreal, QC, Canada",
        "box": [
            197,
            194,
            396,
            203
        ],
        "class": "affili",
        "page": 0,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "2 Carnegie Mellon University, Pittsburgh, PA USA",
        "box": [
            212,
            203,
            381,
            212
        ],
        "class": "affili",
        "page": 0,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "3 Verse Communications, Orinda, CA USA",
        "box": [
            224,
            212,
            367,
            221
        ],
        "class": "affili",
        "page": 0,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "KEY WORDS: performance; measurement; index compression; vector processing",
        "box": [
            93,
            277,
            409,
            287
        ],
        "class": "fstline",
        "page": 0,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "1. INTRODUCTION",
        "box": [
            251,
            327,
            341,
            337
        ],
        "class": "sec1",
        "page": 0,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "An inverted index maps terms to lists of document identifiers. A column index in a database",
        "box": [
            93,
            351,
            500,
            361
        ],
        "class": "fstline",
        "page": 0,
        "is_meta": false,
        "parent_id": 7,
        "relation": "contain"
    },
    {
        "text": "might, similarly, map attribute values to row identifiers. Storing all these lists on disk can limit",
        "box": [
            93,
            363,
            500,
            373
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 8,
        "relation": "connect"
    },
    {
        "text": "the performance since the latency of the fastest drives is several orders of magnitude higher than the",
        "box": [
            93,
            375,
            500,
            385
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 9,
        "relation": "connect"
    },
    {
        "text": "latency of memory. Fast compression can reduce query response times [1, 2].",
        "box": [
            93,
            387,
            410,
            397
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 10,
        "relation": "connect"
    },
    {
        "text": "We assume that identifiers can be represented using 32-bit integers and that they are stored in",
        "box": [
            103,
            399,
            500,
            409
        ],
        "class": "fstline",
        "page": 0,
        "is_meta": false,
        "parent_id": 8,
        "relation": "equality"
    },
    {
        "text": "sorted order. In this context, one can achieve good compression ratios and high decompression",
        "box": [
            93,
            411,
            500,
            421
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 12,
        "relation": "connect"
    },
    {
        "text": "speed, by employing differential coding. We exploit the fact that the lists are sorted and instead of",
        "box": [
            93,
            422,
            500,
            433
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 13,
        "relation": "connect"
    },
    {
        "text": "storing the integers themselves, we store the differences between successive integers, sometimes",
        "box": [
            93,
            435,
            500,
            445
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 14,
        "relation": "connect"
    },
    {
        "text": "called the deltas.",
        "box": [
            93,
            447,
            162,
            457
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 15,
        "relation": "connect"
    },
    {
        "text": "Additional improvements arise from using the single instruction, multiple data (SIMD)",
        "box": [
            103,
            458,
            500,
            469
        ],
        "class": "fstline",
        "page": 0,
        "is_meta": false,
        "parent_id": 12,
        "relation": "equality"
    },
    {
        "text": "instructions available on practically all server and desktop processors produced in the last decade",
        "box": [
            93,
            470,
            500,
            481
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 17,
        "relation": "connect"
    },
    {
        "text": "(Streaming SIMD Extensions 2 or SSE2). A SIMD instruction performs the same operation on",
        "box": [
            93,
            482,
            500,
            493
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 18,
        "relation": "connect"
    },
    {
        "text": "multiple pieces of data: this is also known as vector processing. Previous research [3] showed that",
        "box": [
            93,
            494,
            500,
            505
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 19,
        "relation": "connect"
    },
    {
        "text": "we can decode compressed 32-bit integers using less than 1.5 CPU cycles per integer in a realistic",
        "box": [
            93,
            506,
            500,
            517
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 20,
        "relation": "connect"
    },
    {
        "text": "inverted index scenario by using SIMD instructions. We expect that this is at least twice as fast as",
        "box": [
            93,
            518,
            500,
            529
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 21,
        "relation": "connect"
    },
    {
        "text": "any non-SIMD scheme.",
        "box": [
            93,
            530,
            191,
            540
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 22,
        "relation": "connect"
    },
    {
        "text": "One downside of differential coding is that decompression requires the computation of a prefix",
        "box": [
            103,
            542,
            500,
            552
        ],
        "class": "fstline",
        "page": 0,
        "is_meta": false,
        "parent_id": 17,
        "relation": "equality"
    },
    {
        "text": "sum to recover the original integers [4]: given the delta values \u03b42 , \u03b43, . . . and an initial value x1 ,",
        "box": [
            93,
            554,
            500,
            565
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 24,
        "relation": "connect"
    },
    {
        "text": "we must compute x1 + \u03b42, x1 + \u03b42 + \u03b43 , x1 + \u03b42 + \u03b43 + \u03b44 + . . .. When using earlier non-SIMD",
        "box": [
            93,
            566,
            500,
            577
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 25,
        "relation": "connect"
    },
    {
        "text": "compression techniques, the computational cost of the prefix sum might be relatively small, but",
        "box": [
            93,
            578,
            500,
            588
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 26,
        "relation": "connect"
    },
    {
        "text": "when using faster SIMD compression, the prefix sum can account for up to half of the running time.",
        "box": [
            93,
            590,
            500,
            600
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 27,
        "relation": "connect"
    },
    {
        "text": "Thankfully we can accelerate the computation of the prefix sum using SIMD instructions.",
        "box": [
            93,
            602,
            461,
            612
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 28,
        "relation": "connect"
    },
    {
        "text": "Our first contribution is to revisit the computation of the prefix sum. On 128-bit SIMD vectors, we",
        "box": [
            103,
            614,
            500,
            624
        ],
        "class": "fstline",
        "page": 0,
        "is_meta": false,
        "parent_id": 24,
        "relation": "equality"
    },
    {
        "text": "introduce four variations exhibiting various speed/compression trade-offs, from the most common",
        "box": [
            93,
            626,
            500,
            636
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 30,
        "relation": "connect"
    },
    {
        "text": "one, to the 4-wise approach proposed by Lemire and Boytsov [3]. In particular, we show that",
        "box": [
            93,
            638,
            500,
            648
        ],
        "class": "para",
        "page": 0,
        "is_meta": false,
        "parent_id": 31,
        "relation": "connect"
    },
    {
        "text": "\u2217Correspondence to: LICEF Research Center, TELUQ, Universit\u00b4e du Qu \u00b4ebec, 5800 Saint-Denis, Montreal (Quebec)",
        "box": [
            93,
            674,
            500,
            684
        ],
        "class": "fnote",
        "page": 0,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "H2S 3L5 Canada.",
        "box": [
            93,
            684,
            153,
            693
        ],
        "class": "opara",
        "page": 0,
        "is_meta": true,
        "parent_id": 33,
        "relation": "connect"
    },
    {
        "text": "Contract/grant sponsor: Natural Sciences and Engineering Research Council of Canada; contract/grant number: 261437",
        "box": [
            93,
            702,
            498,
            711
        ],
        "class": "fnote",
        "page": 0,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "2",
        "box": [
            93,
            38,
            98,
            49
        ],
        "class": "header",
        "page": 1,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 1,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "at the same compression ratios, vector (SIMD) decompression is much faster than scalar (non-",
        "box": [
            93,
            68,
            500,
            79
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 32,
        "relation": "connect"
    },
    {
        "text": "SIMD) decompression. Maybe more importantly, we show that integrating the prefix sum with the",
        "box": [
            93,
            80,
            500,
            91
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 38,
        "relation": "connect"
    },
    {
        "text": "unpacking can nearly double the speed. Some of our improved schemes can decompress more than",
        "box": [
            93,
            92,
            500,
            102
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 39,
        "relation": "connect"
    },
    {
        "text": "one 32-bit integer per CPU cycle. We are not aware of any similar high speed previously reported,",
        "box": [
            93,
            104,
            500,
            114
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 40,
        "relation": "connect"
    },
    {
        "text": "even accounting for hardware differences.",
        "box": [
            93,
            116,
            265,
            126
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 41,
        "relation": "connect"
    },
    {
        "text": "To illustrate that SIMD instructions can significantly benefit other aspects of an inverted index",
        "box": [
            103,
            128,
            500,
            138
        ],
        "class": "fstline",
        "page": 1,
        "is_meta": false,
        "parent_id": 30,
        "relation": "equality"
    },
    {
        "text": "(or a database system), we consider the problem of computing conjunctive queries: e.g., finding",
        "box": [
            93,
            140,
            500,
            150
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 43,
        "relation": "connect"
    },
    {
        "text": "all documents that contain a given set of terms. In some search engines, such conjunctive queries",
        "box": [
            93,
            152,
            500,
            162
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 44,
        "relation": "connect"
    },
    {
        "text": "are the first, and, sometimes, the most expensive, step in query processing [5, 6]. Some categories",
        "box": [
            93,
            164,
            500,
            174
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 45,
        "relation": "connect"
    },
    {
        "text": "of users, e.g., patent lawyers [7], prefer to use complex Boolean queries\u2014where conjunction is an",
        "box": [
            93,
            176,
            500,
            186
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 46,
        "relation": "connect"
    },
    {
        "text": "important part of query processing.",
        "box": [
            93,
            188,
            238,
            198
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 47,
        "relation": "connect"
    },
    {
        "text": "Culpepper and Moffat showed that a competitive approach (henceforth HY B + M 2) was to",
        "box": [
            103,
            200,
            500,
            210
        ],
        "class": "fstline",
        "page": 1,
        "is_meta": false,
        "parent_id": 43,
        "relation": "equality"
    },
    {
        "text": "represent the longest lists as bitmaps while continuing to compress the short lists using differential",
        "box": [
            93,
            212,
            500,
            222
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 49,
        "relation": "connect"
    },
    {
        "text": "coding [5]. To compute an intersection, the short lists are first intersected and then the corresponding",
        "box": [
            93,
            224,
            500,
            234
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 50,
        "relation": "connect"
    },
    {
        "text": "bits in the bitmaps are read to finish the computation. As is commonly done, the short lists are",
        "box": [
            93,
            236,
            500,
            246
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 51,
        "relation": "connect"
    },
    {
        "text": "intersected two-by-two starting from the two smallest lists: this is often called a Set-vs-Set or SvS",
        "box": [
            93,
            248,
            500,
            258
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 52,
        "relation": "connect"
    },
    {
        "text": "processing. These intersections are typically computed using scalar algorithms. In fact, we are not",
        "box": [
            93,
            260,
            500,
            270
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 53,
        "relation": "connect"
    },
    {
        "text": "aware of any SIMD intersection algorithm proposed for such problems on CPUs. Thus as our second",
        "box": [
            93,
            272,
            500,
            282
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 54,
        "relation": "connect"
    },
    {
        "text": "contribution, we introduce new SIMD-based intersection algorithms for uncompressed integers that",
        "box": [
            93,
            284,
            500,
            294
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 55,
        "relation": "connect"
    },
    {
        "text": "are up to twice as fast as competitive scalar intersection algorithms. By combining both the fast",
        "box": [
            93,
            295,
            500,
            306
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 56,
        "relation": "connect"
    },
    {
        "text": "SIMD decompression and fast SIMD intersection, we can double the speed of the intersections on",
        "box": [
            93,
            307,
            500,
            318
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 57,
        "relation": "connect"
    },
    {
        "text": "compressed lists.",
        "box": [
            93,
            319,
            163,
            330
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 58,
        "relation": "connect"
    },
    {
        "text": "We summarize our main contributions as follows:",
        "box": [
            103,
            331,
            307,
            342
        ],
        "class": "fstline",
        "page": 1,
        "is_meta": false,
        "parent_id": 49,
        "relation": "equality"
    },
    {
        "text": "1. We show that by combining SIMD unpacking and the prefix sum required by differential",
        "box": [
            105,
            349,
            500,
            359
        ],
        "class": "fstline",
        "page": 1,
        "is_meta": false,
        "parent_id": 60,
        "relation": "equality"
    },
    {
        "text": "coding, we can improve decompression speed by up to 90 %. We end up beating by about",
        "box": [
            118,
            360,
            500,
            371
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 61,
        "relation": "connect"
    },
    {
        "text": "30 % the previous best reported decompression speeds [3].",
        "box": [
            118,
            372,
            358,
            383
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 62,
        "relation": "connect"
    },
    {
        "text": "2. We introduce a family of intersection algorithms to exploit commonly available SIMD",
        "box": [
            105,
            391,
            500,
            401
        ],
        "class": "fstline",
        "page": 1,
        "is_meta": false,
        "parent_id": 61,
        "relation": "equality"
    },
    {
        "text": "instructions (V1 , V3 and S I MD G AL LO P IN G ). They are often twice as fast as the best non-",
        "box": [
            118,
            403,
            500,
            413
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 64,
        "relation": "connect"
    },
    {
        "text": "SIMD algorithms.",
        "box": [
            118,
            415,
            193,
            425
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 65,
        "relation": "connect"
    },
    {
        "text": "3. By combining our results, we nearly double the speed of a fast inverted index ( H YB+ M 2) over",
        "box": [
            105,
            433,
            500,
            444
        ],
        "class": "fstline",
        "page": 1,
        "is_meta": false,
        "parent_id": 64,
        "relation": "equality"
    },
    {
        "text": "realistic data and queries\u2014on standard PC processors.",
        "box": [
            118,
            445,
            341,
            456
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 67,
        "relation": "connect"
    },
    {
        "text": "To ease reproducibility, we make all of the software and data sets publicly available, including",
        "box": [
            103,
            463,
            500,
            473
        ],
        "class": "fstline",
        "page": 1,
        "is_meta": false,
        "parent_id": 67,
        "relation": "equality"
    },
    {
        "text": "the software to process the text collections and generate query mappings (see \u00a7 7.1 and \u00a7 7.3).",
        "box": [
            93,
            475,
            479,
            485
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 69,
        "relation": "connect"
    },
    {
        "text": "2. RELATED WORK",
        "box": [
            250,
            510,
            342,
            520
        ],
        "class": "sec1",
        "page": 1,
        "is_meta": false,
        "parent_id": 7,
        "relation": "equality"
    },
    {
        "text": "For an exhaustive review of fast 32-bit integer compression techniques, we refer the reader to Lemire",
        "box": [
            93,
            534,
            500,
            544
        ],
        "class": "fstline",
        "page": 1,
        "is_meta": false,
        "parent_id": 71,
        "relation": "contain"
    },
    {
        "text": "and Boytsov [3]. Their main finding is that schemes compressing integers in large (\u2248 128) blocks",
        "box": [
            93,
            546,
            500,
            556
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 72,
        "relation": "connect"
    },
    {
        "text": "of integers with minimal branching are faster than other approaches, especially when using SIMD",
        "box": [
            93,
            557,
            500,
            568
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 73,
        "relation": "connect"
    },
    {
        "text": "instructions. They reported using fewer than 1.5 CPU cycles per 32-bit integer on a 2011-era Intel",
        "box": [
            93,
            569,
            500,
            580
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 74,
        "relation": "connect"
    },
    {
        "text": "Sandy Bridge processor. In comparison, Stepanov et al. [8] also proposed compression schemes",
        "box": [
            93,
            581,
            500,
            592
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 75,
        "relation": "connect"
    },
    {
        "text": "optimized for SIMD instructions on CPUs, but they reported using at least 2.2 CPU cycles per",
        "box": [
            93,
            593,
            500,
            604
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 76,
        "relation": "connect"
    },
    {
        "text": "32-bit integer on a 2010 Intel Westmere processor.",
        "box": [
            93,
            605,
            298,
            616
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 77,
        "relation": "connect"
    },
    {
        "text": "Regarding the intersection of sorted integer lists, Ding and K \u00a8onig [9] compared a wide range of",
        "box": [
            103,
            617,
            500,
            628
        ],
        "class": "fstline",
        "page": 1,
        "is_meta": false,
        "parent_id": 72,
        "relation": "equality"
    },
    {
        "text": "algorithms in the context of a search engine and found that SvS with galloping was competitive:",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 79,
        "relation": "connect"
    },
    {
        "text": "we describe galloping in \u00a7 6. Their own technique (RanGroup) performed better (\u224810 %\u201330 %) but",
        "box": [
            93,
            641,
            500,
            651
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 80,
        "relation": "connect"
    },
    {
        "text": "it does not operate over sorted lists but rather over a specialized data structure that divides up the",
        "box": [
            93,
            653,
            500,
            663
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 81,
        "relation": "connect"
    },
    {
        "text": "data randomly into small chunks. In some instances, they found that a merge (akin to the merge",
        "box": [
            93,
            665,
            500,
            675
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 82,
        "relation": "connect"
    },
    {
        "text": "step in the merge sort algorithm) was faster. They also achieved good results with Lookup [10]: a",
        "box": [
            93,
            677,
            500,
            687
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 83,
        "relation": "connect"
    },
    {
        "text": "technique that relies on an auxiliary data structure for skipping values [11]. Ding and K\u00a8onig found",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 84,
        "relation": "connect"
    },
    {
        "text": "that alternatives such as Baeza-Yates\u2019 algorithm [12] or adaptive algorithms [13] were slower.",
        "box": [
            93,
            701,
            478,
            711
        ],
        "class": "para",
        "page": 1,
        "is_meta": false,
        "parent_id": 85,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 2,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "3",
        "box": [
            494,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 2,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Barbay et al. [14] also carried out an extensive experimental evaluation. On synthetic data using a",
        "box": [
            103,
            68,
            500,
            79
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 79,
        "relation": "equality"
    },
    {
        "text": "uniform distribution, they found that Baeza-Yates\u2019 algorithm [12] was faster than SvS with galloping",
        "box": [
            93,
            80,
            500,
            91
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 89,
        "relation": "connect"
    },
    {
        "text": "(by about 30 %). However, on real data (e.g., TREC GOV2), SvS with galloping was superior to most",
        "box": [
            93,
            92,
            500,
            102
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 90,
        "relation": "connect"
    },
    {
        "text": "alternatives by a wide margin (e.g., 2\u00d7 faster).",
        "box": [
            93,
            104,
            284,
            114
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 91,
        "relation": "connect"
    },
    {
        "text": "Culpepper and Moffat similarly found that SvS with galloping was the fastest [5] though their own",
        "box": [
            103,
            116,
            500,
            126
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 89,
        "relation": "equality"
    },
    {
        "text": "max algorithm was fast as well. They found that in some specific instances (for queries containing",
        "box": [
            93,
            127,
            500,
            138
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 93,
        "relation": "connect"
    },
    {
        "text": "9 or more terms) a technique similar to galloping (interpolative search) was slightly better (by less",
        "box": [
            93,
            140,
            500,
            150
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 94,
        "relation": "connect"
    },
    {
        "text": "than 10 %).",
        "box": [
            93,
            152,
            139,
            162
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 95,
        "relation": "connect"
    },
    {
        "text": "Kane and Tompa improved Culpepper and Moffat\u2019s HY B +M 2 by adding auxiliary data structures",
        "box": [
            103,
            164,
            500,
            174
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 93,
        "relation": "equality"
    },
    {
        "text": "to skip over large blocks of compressed values (256 integers) during the computation of the",
        "box": [
            93,
            176,
            500,
            186
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 97,
        "relation": "connect"
    },
    {
        "text": "intersection [15]. Their good results are in contrast with Culpepper and Moffat\u2019s finding that",
        "box": [
            93,
            188,
            500,
            198
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 98,
        "relation": "connect"
    },
    {
        "text": "skipping is counterproductive when using bitmaps [5].",
        "box": [
            93,
            200,
            316,
            210
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 99,
        "relation": "connect"
    },
    {
        "text": "Our work is focused on commodity desktop processors. Compression and intersection of integer",
        "box": [
            103,
            212,
            500,
            222
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 97,
        "relation": "equality"
    },
    {
        "text": "lists using a graphics processing unit (GPU) has also received attention. Ding et al. [16] improved",
        "box": [
            93,
            224,
            500,
            234
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 101,
        "relation": "connect"
    },
    {
        "text": "the intersection speed using a parallel merge find: essentially, they divide up one list into small",
        "box": [
            93,
            235,
            500,
            246
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 102,
        "relation": "connect"
    },
    {
        "text": "blocks and intersect these blocks in parallel with the other array. On conjunctive queries, Ding et",
        "box": [
            93,
            248,
            500,
            258
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 103,
        "relation": "connect"
    },
    {
        "text": "al. [16] found their GPU implementation to be only marginally superior to a CPU implementation",
        "box": [
            93,
            260,
            500,
            270
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 104,
        "relation": "connect"
    },
    {
        "text": "(\u224815 % faster) despite the data was already loaded in GPU\u2019s global memory. They do, however, get",
        "box": [
            93,
            272,
            500,
            282
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 105,
        "relation": "connect"
    },
    {
        "text": "impressive speed gains (7\u00d7) on disjunctive queries.",
        "box": [
            93,
            284,
            304,
            294
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 106,
        "relation": "connect"
    },
    {
        "text": "Ao et al. [17] proposed a parallelized compression technique (Parallel PFor) and replaced",
        "box": [
            103,
            295,
            500,
            306
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 101,
        "relation": "equality"
    },
    {
        "text": "conventional differential coding with an approach based on linear regression. In our work, we rely",
        "box": [
            93,
            307,
            500,
            318
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 108,
        "relation": "connect"
    },
    {
        "text": "critically on differential coding, but alternative models merit consideration [18, 19, 20].",
        "box": [
            93,
            319,
            452,
            330
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 109,
        "relation": "connect"
    },
    {
        "text": "3. RELEVANT SIMD INSTRUCTIONS",
        "box": [
            211,
            354,
            381,
            365
        ],
        "class": "sec1",
        "page": 2,
        "is_meta": false,
        "parent_id": 71,
        "relation": "equality"
    },
    {
        "text": "Intel PC processors support vector instructions, but languages such as C or C++ do not directly",
        "box": [
            93,
            378,
            500,
            388
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 111,
        "relation": "contain"
    },
    {
        "text": "include vectorization as part of their standard syntax. However, it is still possible to conveniently",
        "box": [
            93,
            390,
            500,
            400
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 112,
        "relation": "connect"
    },
    {
        "text": "call these instructions by using intrinsics or online assembly code. Intrinsics are special functions",
        "box": [
            93,
            402,
            500,
            412
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 113,
        "relation": "connect"
    },
    {
        "text": "(sometimes called built-in functions) provided as a compiler extension of C/C++ syntax.",
        "box": [
            93,
            414,
            456,
            424
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 114,
        "relation": "connect"
    },
    {
        "text": "Table I presents the various SIMD instructions we require. In addition to instruction mnemonic",
        "box": [
            103,
            426,
            500,
            436
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 112,
        "relation": "equality"
    },
    {
        "text": "names, we also provide names of respective C/C++ intrinsics. In this table, there is a single intrinsic",
        "box": [
            93,
            438,
            500,
            448
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 116,
        "relation": "connect"
    },
    {
        "text": "function per mnemonic except for the move instruction movdqu, which has separate intrinsics to",
        "box": [
            93,
            449,
            500,
            460
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 117,
        "relation": "connect"
    },
    {
        "text": "denote store and load operations.",
        "box": [
            93,
            462,
            228,
            472
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 118,
        "relation": "connect"
    },
    {
        "text": "Though most of the instructions are fast, some are significantly more expensive. Intel often",
        "box": [
            103,
            474,
            500,
            484
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 116,
        "relation": "equality"
    },
    {
        "text": "expresses the computational cost of an instruction in terms of its latency and reciprocal throughput.",
        "box": [
            93,
            486,
            500,
            496
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 120,
        "relation": "connect"
    },
    {
        "text": "The latency is the minimum number of cycles required to execute the instruction. The reciprocal",
        "box": [
            93,
            498,
            500,
            508
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 121,
        "relation": "connect"
    },
    {
        "text": "throughput is one over the maximum number of instructions of the same kind that can be executed",
        "box": [
            93,
            510,
            500,
            520
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 122,
        "relation": "connect"
    },
    {
        "text": "per cycle. For example, a reciprocal throughput of 0.5 indicates that up to two instructions of the",
        "box": [
            93,
            522,
            500,
            532
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 123,
        "relation": "connect"
    },
    {
        "text": "same type can be executed in a cycle. We give the latency and reciprocal throughput for Intel",
        "box": [
            93,
            534,
            500,
            544
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 124,
        "relation": "connect"
    },
    {
        "text": "processors with a Sandy Bridge microarchitecture [21]. These numbers are often constant across",
        "box": [
            93,
            545,
            500,
            556
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 125,
        "relation": "connect"
    },
    {
        "text": "Intel microarchitectures.",
        "box": [
            93,
            557,
            193,
            568
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 126,
        "relation": "connect"
    },
    {
        "text": "All of these instructions use 128-bit registers (called XMM registers). Many of them are",
        "box": [
            103,
            569,
            500,
            580
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 120,
        "relation": "equality"
    },
    {
        "text": "straightforward. For example, por and pand compute the bitwise OR and AND between two",
        "box": [
            93,
            581,
            500,
            592
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 128,
        "relation": "connect"
    },
    {
        "text": "registers.",
        "box": [
            93,
            593,
            130,
            604
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 129,
        "relation": "connect"
    },
    {
        "text": "We use the movdqu instruction to load or store a register. Loading and storing registers has a",
        "box": [
            103,
            605,
            500,
            616
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 128,
        "relation": "equality"
    },
    {
        "text": "relatively high latency (3 cycles). While we can load two registers per cycle, we can only store one",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 131,
        "relation": "connect"
    },
    {
        "text": "of them to memory.",
        "box": [
            93,
            629,
            174,
            639
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 132,
        "relation": "connect"
    },
    {
        "text": "The bit shifting instructions come in two flavors. When we need to shift entire registers by a",
        "box": [
            103,
            641,
            500,
            651
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 131,
        "relation": "equality"
    },
    {
        "text": "number of bits divisible by eight (a byte), we use the psrldq and pslldq instructions. They have",
        "box": [
            93,
            652,
            500,
            663
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 134,
        "relation": "connect"
    },
    {
        "text": "a high throughput (2 instructions per cycle) on Sandy Bridge Intel processors [22].",
        "box": [
            93,
            665,
            431,
            675
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 135,
        "relation": "connect"
    },
    {
        "text": "We can also consider the 128-bit registers as a vector of four 32-bit integers. We can then shift",
        "box": [
            103,
            677,
            500,
            687
        ],
        "class": "fstline",
        "page": 2,
        "is_meta": false,
        "parent_id": 134,
        "relation": "equality"
    },
    {
        "text": "right four 32-bit integers by a fixed number of bits using the psrld instruction. It has reduced",
        "box": [
            93,
            688,
            500,
            699
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 137,
        "relation": "connect"
    },
    {
        "text": "throughput compared to the byte-shifting instructions (1 instruction per cycle).",
        "box": [
            93,
            701,
            416,
            711
        ],
        "class": "para",
        "page": 2,
        "is_meta": false,
        "parent_id": 138,
        "relation": "connect"
    },
    {
        "text": "4",
        "box": [
            93,
            38,
            98,
            49
        ],
        "class": "header",
        "page": 3,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 3,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "In the same spirit, we can add four 32-bit integers with four other 32-bit integers at once using",
        "box": [
            103,
            68,
            500,
            79
        ],
        "class": "fstline",
        "page": 3,
        "is_meta": false,
        "parent_id": 137,
        "relation": "equality"
    },
    {
        "text": "the paddd instruction. It is another fast operation.",
        "box": [
            93,
            80,
            301,
            91
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 142,
        "relation": "connect"
    },
    {
        "text": "Sometimes it is necessary to copy the 32-bit integers from one XMM register to another, while",
        "box": [
            103,
            92,
            500,
            102
        ],
        "class": "fstline",
        "page": 3,
        "is_meta": false,
        "parent_id": 142,
        "relation": "equality"
    },
    {
        "text": "possibly moving or duplicating values. The pshufd instruction can serve this purpose. It takes",
        "box": [
            93,
            103,
            500,
            114
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 144,
        "relation": "connect"
    },
    {
        "text": "as a parameter an input register v as well as a control mask m. The control mask is made of four",
        "box": [
            93,
            116,
            500,
            126
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 145,
        "relation": "connect"
    },
    {
        "text": "2-bit integers each representing an integer in {0, 1, 2, 3}. We output (vm0 , vm1 , vm2 , vm3 ). Thus, for",
        "box": [
            93,
            128,
            500,
            140
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 146,
        "relation": "connect"
    },
    {
        "text": "example, the pshufd instruction can copy one particular value to all positions (using a mask made",
        "box": [
            93,
            139,
            500,
            150
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 147,
        "relation": "connect"
    },
    {
        "text": "of 4 identical values). It is a fast instruction with a throughput of two instructions per cycle.",
        "box": [
            93,
            152,
            468,
            162
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 148,
        "relation": "connect"
    },
    {
        "text": "We can compare the four 32-bit integers of one register v with the four 32-bit integers of another",
        "box": [
            103,
            164,
            500,
            174
        ],
        "class": "fstline",
        "page": 3,
        "is_meta": false,
        "parent_id": 144,
        "relation": "equality"
    },
    {
        "text": "register v\u2032 using the pcmpeqd instruction. It generates four 32-bit integers with value 0xFFFFFFFF",
        "box": [
            93,
            175,
            500,
            186
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 150,
        "relation": "connect"
    },
    {
        "text": "or 0 depending on whether the corresponding pairs of integers are equal (e.g., if v0 = v \u20320 , then the",
        "box": [
            93,
            187,
            500,
            200
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 151,
        "relation": "connect"
    },
    {
        "text": "first component returned by pcmpeqd has value 0xFFFFFFFF).",
        "box": [
            93,
            199,
            358,
            210
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 152,
        "relation": "connect"
    },
    {
        "text": "The pcmpeqd instruction can be used in tandem with the movmskps instruction, which",
        "box": [
            103,
            211,
            500,
            222
        ],
        "class": "fstline",
        "page": 3,
        "is_meta": false,
        "parent_id": 150,
        "relation": "equality"
    },
    {
        "text": "generates a 4-bit mask by extracting the four most significant bits from the four 32-bit integers",
        "box": [
            93,
            224,
            500,
            234
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 154,
        "relation": "connect"
    },
    {
        "text": "produced by the comparison instruction pcmpeqd. The movmskps instruction is slightly",
        "box": [
            93,
            235,
            500,
            246
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 155,
        "relation": "connect"
    },
    {
        "text": "expensive, with a throughput of 1 instruction per cycle and a latency of 2 cycles. In some cases,",
        "box": [
            93,
            248,
            500,
            258
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 156,
        "relation": "connect"
    },
    {
        "text": "we only need to verify if four 32-bit integers in one register are different from respective 32-bit",
        "box": [
            93,
            260,
            500,
            270
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 157,
        "relation": "connect"
    },
    {
        "text": "integers in another register, i.e., we do not need to extract a mask. To check this, we use either the",
        "box": [
            93,
            272,
            500,
            282
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 158,
        "relation": "connect"
    },
    {
        "text": "SSE2 instruction pmovmskb or the SSE4 instruction ptest. The SSE4 instruction has smaller",
        "box": [
            93,
            283,
            500,
            294
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 159,
        "relation": "connect"
    },
    {
        "text": "latency, however, replacing ptest with pmovmskb did not substantially affect runtime.",
        "box": [
            93,
            295,
            459,
            306
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 160,
        "relation": "connect"
    },
    {
        "text": "In some particular algorithms (see \u00a7 6.1), we also use two recently introduced string-comparison",
        "box": [
            103,
            307,
            500,
            318
        ],
        "class": "fstline",
        "page": 3,
        "is_meta": false,
        "parent_id": 154,
        "relation": "equality"
    },
    {
        "text": "instructions (part of the SSE4 instruction set): pcmpestrm and pcmpistrm. They operate on",
        "box": [
            93,
            319,
            500,
            330
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 162,
        "relation": "connect"
    },
    {
        "text": "8-bit or 16-bit strings loaded in XMM registers. They take a control mask to specify their behavior.",
        "box": [
            93,
            331,
            500,
            342
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 163,
        "relation": "connect"
    },
    {
        "text": "We use them for 16-bit strings. For our purposes, we ask for a 8-bit mask indicating whether any",
        "box": [
            93,
            343,
            500,
            354
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 164,
        "relation": "connect"
    },
    {
        "text": "of the eight 16-bit elements of the first register are equal to any of the eight 16-bit elements of the",
        "box": [
            93,
            355,
            500,
            366
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 165,
        "relation": "connect"
    },
    {
        "text": "second register. This mask is stored in a 128-bit MMX register and is extracted using the pextrd",
        "box": [
            93,
            366,
            500,
            377
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 166,
        "relation": "connect"
    },
    {
        "text": "instruction.",
        "box": [
            93,
            379,
            140,
            389
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 167,
        "relation": "connect"
    },
    {
        "text": "The two string-comparison instructions differ in how they deduce the string length. The slower",
        "box": [
            103,
            391,
            500,
            401
        ],
        "class": "fstline",
        "page": 3,
        "is_meta": false,
        "parent_id": 162,
        "relation": "equality"
    },
    {
        "text": "pcmpestrm instruction requires us to specify the string lengths (8 elements in our case). The faster",
        "box": [
            93,
            402,
            500,
            413
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 169,
        "relation": "connect"
    },
    {
        "text": "pcmpistrm instruction assumes that strings are null terminated. When no null value is found, the",
        "box": [
            93,
            414,
            500,
            425
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 170,
        "relation": "connect"
    },
    {
        "text": "pcmpistrm instruction processes 8 elements per register. There is no 16-bit counterpart to the",
        "box": [
            93,
            426,
            500,
            437
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 171,
        "relation": "connect"
    },
    {
        "text": "pshufd instruction, but there is an 8-bit version (pshufb) with the same latency and throughput.",
        "box": [
            93,
            438,
            499,
            449
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 172,
        "relation": "connect"
    },
    {
        "text": "4. INTEGER COMPRESSION",
        "box": [
            231,
            477,
            362,
            488
        ],
        "class": "sec1",
        "page": 3,
        "is_meta": false,
        "parent_id": 111,
        "relation": "equality"
    },
    {
        "text": "We consider the case where we have lists of integers stored using 32 bits, but where the magnitude",
        "box": [
            93,
            501,
            500,
            511
        ],
        "class": "fstline",
        "page": 3,
        "is_meta": false,
        "parent_id": 174,
        "relation": "contain"
    },
    {
        "text": "of most integers requires fewer than 32-bits to express. We want to compress them while spending",
        "box": [
            93,
            513,
            500,
            523
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 175,
        "relation": "connect"
    },
    {
        "text": "as few CPU cycles per integer as possible.",
        "box": [
            93,
            525,
            266,
            535
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 176,
        "relation": "connect"
    },
    {
        "text": "There has been much work on the design and analysis of integer compression schemes. Out of",
        "box": [
            103,
            537,
            500,
            547
        ],
        "class": "fstline",
        "page": 3,
        "is_meta": false,
        "parent_id": 175,
        "relation": "equality"
    },
    {
        "text": "an earlier survey [3], we choose 4 previously described fast compression schemes: VA R I NT , S4 -",
        "box": [
            93,
            549,
            499,
            559
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 178,
        "relation": "connect"
    },
    {
        "text": "B P 1 28 , FA S TP F O R and S4 - FA S TP F O R. Both S 4 -B P1 28 and S4 - FA S TPF O R performed best in",
        "box": [
            93,
            561,
            500,
            571
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 179,
        "relation": "connect"
    },
    {
        "text": "an exhaustive experimental comparison [3]. We review them briefly for completeness.",
        "box": [
            93,
            573,
            446,
            583
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 180,
        "relation": "connect"
    },
    {
        "text": "4.1. VA R IN T",
        "box": [
            93,
            599,
            148,
            610
        ],
        "class": "sec2",
        "page": 3,
        "is_meta": false,
        "parent_id": 174,
        "relation": "contain"
    },
    {
        "text": "Many authors such as Culpepper and Moffat [5] use variable byte codes (henceforth VA R INT ) also",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "fstline",
        "page": 3,
        "is_meta": false,
        "parent_id": 182,
        "relation": "contain"
    },
    {
        "text": "known as escaping [10] for compressing integers. It was first described by Thiel and Heaps [23].",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 183,
        "relation": "connect"
    },
    {
        "text": "For example, we might code integers in [0, 27) using a single byte, integers in [27, 214) using",
        "box": [
            93,
            640,
            500,
            651
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 184,
        "relation": "connect"
    },
    {
        "text": "two bytes and so on. As an example, consider the integers 1, 3840, 131073, and 2, and Fig. 1.",
        "box": [
            93,
            653,
            500,
            663
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 185,
        "relation": "connect"
    },
    {
        "text": "In Fig. 1a, we give the usual 32-bit integer layout for these integers, it uses 16 bytes. In binary",
        "box": [
            93,
            665,
            500,
            675
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 186,
        "relation": "connect"
    },
    {
        "text": "format, these numbers can be written 1, 111100000000, 100000000000000001 and 10 (writing",
        "box": [
            93,
            677,
            500,
            687
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 187,
        "relation": "connect"
    },
    {
        "text": "the most significant bits first). The first integer can be written using a single byte since it is in",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 188,
        "relation": "connect"
    },
    {
        "text": "[0, 27 ). To indicate that the byte corresponds to a complete integer, we set the most significant bit",
        "box": [
            93,
            700,
            500,
            711
        ],
        "class": "para",
        "page": 3,
        "is_meta": false,
        "parent_id": 189,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 4,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "5",
        "box": [
            494,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 4,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Table I. SIMD instructions on Sandy Bridge Intel processors with latencies and reciprocal throughput in",
        "box": [
            93,
            66,
            500,
            75
        ],
        "class": "tabcap",
        "page": 4,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "CPU cycles . All instructions are part of SSE2, except pcmpestrm, pcmpistrm, pextrd, popcnt,",
        "box": [
            93,
            75,
            500,
            85
        ],
        "class": "opara",
        "page": 4,
        "is_meta": false,
        "parent_id": 193,
        "relation": "connect"
    },
    {
        "text": "ptest that are SSE4 instructions, and pshufb that is an SSSE3 instruction.",
        "box": [
            149,
            85,
            443,
            95
        ],
        "class": "opara",
        "page": 4,
        "is_meta": false,
        "parent_id": 194,
        "relation": "connect"
    },
    {
        "text": "instruction C/C++ intrinsic description latency rec. thr.por mm or si128 bitwise OR 1 0.33pand mm and si128 bitwise AND 1 0.33movdqu mm storeu si128 store a 128-bit register 3 1movdqu mm loadu si128 load to 128-bit register 3 0.5psrldq mm srli si128 shift right by a number of bytes 1 0.5pslldq mm slli si128 shift left by a number of bytes 1 0.5psrld mm srl epi32 shift right four 32-bit integers 1 1pslld mm sll epi32 shift left four 32-bit integers 1 1paddd mm add epi32 add four 32-bit integers 1 0.5pshufd mm shuffle epi32 shuffle four 32-bit integers 1 0.5pcmpeqd mm cmpeq epi32 compare four 32-bit integers forequality 1 0.5movmskps mm movemask ps mask from most significant bits of32-bit elements 2 1pmovmskb mm movemask epi8 mask from most significant bits of16-bit elements 2 1pcmpestrm mm cmpestrm compare two strings of specificlengths 12 4pcmpistrm mm cmpistrm compare two null-terminatedstrings 11 3pshufb mm shuffle epi8 shuffle 16 bytes 1 0.5pextrd mm extract epi32 extract a specified 32 bit integer 2 1popcnt mm popcnt u32 number of 1s in a 32-bit integer 3 1ptest mm testz si128 performs a bitwise and of two128-bit integers; returns one, ifthe result is all zeros, and zerootherwise. 1 1",
        "box": [
            92,
            105,
            497,
            459
        ],
        "class": "tab",
        "page": 4,
        "is_meta": false,
        "parent_id": 193,
        "relation": "contain"
    },
    {
        "text": "to 1: 10000001. The integer 3840 is in [27 , 214 ), so we represent it using two bytes. The first byte",
        "box": [
            93,
            478,
            500,
            490
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 190,
        "relation": "connect"
    },
    {
        "text": "corresponds to the first 7 bits and has 0 as its most significant bit to indicate that it does not represent",
        "box": [
            93,
            491,
            500,
            501
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 197,
        "relation": "connect"
    },
    {
        "text": "a full integer (000000001). The second byte includes the remaining bits and has 1 as its most",
        "box": [
            93,
            503,
            500,
            513
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 198,
        "relation": "connect"
    },
    {
        "text": "significant bit (10011110). We proceed similarly for the integers 131073 and 2 (see Fig. 1b). Overall,",
        "box": [
            93,
            515,
            500,
            525
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 199,
        "relation": "connect"
    },
    {
        "text": "VARIN T using 7 bytes instead of the original 16 bytes. VARIN T does not always compress well: it",
        "box": [
            93,
            527,
            500,
            537
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 200,
        "relation": "connect"
    },
    {
        "text": "always uses at least one byte per integer. However, if most integers can be represented with a single",
        "box": [
            93,
            539,
            500,
            549
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 201,
        "relation": "connect"
    },
    {
        "text": "byte, then it offers competitive decompression speed [3]. Stepanov et al. [8] reviewed VARIN T-",
        "box": [
            93,
            551,
            500,
            561
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 202,
        "relation": "connect"
    },
    {
        "text": "like alternatives that use SIMD instructions. Lemire and Boytsov [3] found that the fastest such",
        "box": [
            93,
            563,
            500,
            573
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 203,
        "relation": "connect"
    },
    {
        "text": "alternative (varint-G8IU) was slower and did not compress as well as other SIMD-based schemes.",
        "box": [
            93,
            575,
            495,
            585
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 204,
        "relation": "connect"
    },
    {
        "text": "4.2. Bit packing and unpacking",
        "box": [
            93,
            599,
            223,
            609
        ],
        "class": "sec2",
        "page": 4,
        "is_meta": false,
        "parent_id": 182,
        "relation": "equality"
    },
    {
        "text": "Consider once more the integers 1, 3840, 131073, and 2, and Fig. 1. The largest of them is 131073",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "fstline",
        "page": 4,
        "is_meta": false,
        "parent_id": 206,
        "relation": "contain"
    },
    {
        "text": "and it can be represented using 18 bits in binary format (as 100000000000000001). Thus we could",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 207,
        "relation": "connect"
    },
    {
        "text": "decide to write the four integers using exactly 18 bits per integer. The result in memory might look",
        "box": [
            93,
            641,
            500,
            651
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 208,
        "relation": "connect"
    },
    {
        "text": "like Fig. 1c and span 9 bytes. We call this process bit packing, and the reverse process bit unpacking",
        "box": [
            93,
            653,
            500,
            663
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 209,
        "relation": "connect"
    },
    {
        "text": "(see Table II for a summary of our terminology).",
        "box": [
            93,
            665,
            293,
            675
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 210,
        "relation": "connect"
    },
    {
        "text": "The consecutive layout of Fig. 1 is adequate for scalar processing: unpacking an integer can be",
        "box": [
            103,
            677,
            500,
            687
        ],
        "class": "fstline",
        "page": 4,
        "is_meta": false,
        "parent_id": 207,
        "relation": "equality"
    },
    {
        "text": "done efficiently using shifts and bitwise logical operations. However, when using SIMD processing,",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 212,
        "relation": "connect"
    },
    {
        "text": "we want to pack and unpack several (e.g., 4) integers at once. For this reason, we choose to interleave",
        "box": [
            93,
            701,
            500,
            711
        ],
        "class": "para",
        "page": 4,
        "is_meta": false,
        "parent_id": 213,
        "relation": "connect"
    },
    {
        "text": "6",
        "box": [
            93,
            38,
            98,
            49
        ],
        "class": "header",
        "page": 5,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 5,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "1 0 0 0 0 154 \u00d7 4 bytes or 16 bytes0 0 1 0 2 0 2 0 0 0(a) Unsigned binary 32-bit format: for each integer, there arefour unsigned byte values (in little endian representation).1 0 0 01 byte0 0 0 10 0 0 02 bytes0 0 0 01 0 0 1 1 1 1 00 0 0 03 bytes0 0 0 10 0 0 0 0 0 0 01 0 0 0 1 0 0 01 0 0 01 byte0 0 1 0(b) VA RINT format 0 0 0 0 04 \u00d7 18 bits or 9 bytes0 0 10 0 0 0 0 0 0 00 0 0 0 0 0 0 00 0 1 1 1 1 0 00 0 0 1 0 0 0 00 0 0 0 0 0 0 01 0 1 0 0 0 0 00 0 0 0 0 0 0 00 0 0 0 0 0 0 0(c) Packed format",
        "box": [
            183,
            62,
            432,
            315
        ],
        "class": "fig",
        "page": 5,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Figure 1. The sequence of numbers 1, 3840, 131073 and 2 using 3 different data formats. We use a left to",
        "box": [
            93,
            324,
            500,
            333
        ],
        "class": "figcap",
        "page": 5,
        "is_meta": false,
        "parent_id": 217,
        "relation": "contain"
    },
    {
        "text": "right, top to bottom representation, putting most significant bits first in each byte.",
        "box": [
            143,
            334,
            450,
            343
        ],
        "class": "opara",
        "page": 5,
        "is_meta": false,
        "parent_id": 218,
        "relation": "connect"
    },
    {
        "text": "x1 x2 x3 x4 x5 \u00b7 \u00b7 \u00b7x1 x5 x2 x6 x3 x7 x4 x8 \u00b7 x9 \u00b7 \u00b7 \u00b7x5 is split across two words",
        "box": [
            125,
            354,
            472,
            419
        ],
        "class": "fig",
        "page": 5,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Figure 2. Packing 32-bit integers x1, x2 , . . . (top) to 18 bits per integer (bottom) using the interleaved packed",
        "box": [
            93,
            431,
            500,
            441
        ],
        "class": "figcap",
        "page": 5,
        "is_meta": false,
        "parent_id": 220,
        "relation": "contain"
    },
    {
        "text": "format for SIMD processing",
        "box": [
            243,
            441,
            350,
            450
        ],
        "class": "opara",
        "page": 5,
        "is_meta": false,
        "parent_id": 221,
        "relation": "connect"
    },
    {
        "text": "the packed integers as in Fig. 2. In this example, the integers x1 , x2, x3 , x4 are packed to the first",
        "box": [
            93,
            475,
            500,
            486
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 214,
        "relation": "connect"
    },
    {
        "text": "18 bits of 4 consecutive 32-bit words. The first 14 bits of the next integers x5, x6 , x7, x8 are packed",
        "box": [
            93,
            487,
            500,
            498
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 223,
        "relation": "connect"
    },
    {
        "text": "to the next 14 bits of these 32-bit integers, and the remaining 18 \u2212 14 = 4 bits are packed to the",
        "box": [
            93,
            499,
            500,
            510
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 224,
        "relation": "connect"
    },
    {
        "text": "first bits of the next four consecutive 32-bit words. See Lemire and Boytsov [3] for a more detailed",
        "box": [
            93,
            511,
            500,
            521
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 225,
        "relation": "connect"
    },
    {
        "text": "discussion and a comparison with an alternative layout.",
        "box": [
            93,
            523,
            320,
            533
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 226,
        "relation": "connect"
    },
    {
        "text": "Only 4 basic operations are required for bit unpacking: bitwise or, bitwise and, logical shift",
        "box": [
            103,
            535,
            500,
            545
        ],
        "class": "fstline",
        "page": 5,
        "is_meta": false,
        "parent_id": 212,
        "relation": "equality"
    },
    {
        "text": "right, and logical shift left. The corresponding 128-bit SSE2 instructions operating on packed 32-",
        "box": [
            93,
            547,
            500,
            557
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 228,
        "relation": "connect"
    },
    {
        "text": "bit integers are por, pand, psrld, and pslld (in Intel and AMD processors). For a given",
        "box": [
            93,
            558,
            500,
            569
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 229,
        "relation": "connect"
    },
    {
        "text": "bit width b, no branching is required for bit packing or bit unpacking. Thus, we can create one",
        "box": [
            93,
            571,
            500,
            581
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 230,
        "relation": "connect"
    },
    {
        "text": "bit unpacking function for each bit width b and select the desired one using an array of function",
        "box": [
            93,
            583,
            500,
            593
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 231,
        "relation": "connect"
    },
    {
        "text": "pointers or a switch/case statement. In the scalar case, it is most convenient to pack and unpack",
        "box": [
            93,
            594,
            500,
            605
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 232,
        "relation": "connect"
    },
    {
        "text": "integers in units of 32 integers. Given a bit width b, the unpacking procedure outputs b 32-bit",
        "box": [
            93,
            607,
            500,
            617
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 233,
        "relation": "connect"
    },
    {
        "text": "integers. In the vectorized case, we pack and unpack integers in blocks of 128 integers, so that",
        "box": [
            93,
            619,
            500,
            629
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 234,
        "relation": "connect"
    },
    {
        "text": "the unpacking procedure\u2013corresponding to bit width b\u2013generates b 128-bit vectors. A generic bit",
        "box": [
            93,
            631,
            500,
            641
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 235,
        "relation": "connect"
    },
    {
        "text": "unpacking procedure for a block of 128 integers is given by Algorithm 1 and discussed again in \u00a7 5.",
        "box": [
            93,
            643,
            500,
            653
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 236,
        "relation": "connect"
    },
    {
        "text": "4.3. S4 - B P1 28",
        "box": [
            93,
            671,
            160,
            681
        ],
        "class": "sec2",
        "page": 5,
        "is_meta": false,
        "parent_id": 206,
        "relation": "equality"
    },
    {
        "text": "Bit packing suggests a simple scheme: regroup the integers into blocks (e.g. 128 integers) and pack",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "fstline",
        "page": 5,
        "is_meta": false,
        "parent_id": 238,
        "relation": "contain"
    },
    {
        "text": "them as concisely as possible, while recording the bit width (e.g., 18 bits per integer) using an",
        "box": [
            93,
            701,
            500,
            711
        ],
        "class": "para",
        "page": 5,
        "is_meta": false,
        "parent_id": 239,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 6,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "7",
        "box": [
            494,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 6,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "extra byte. We call this approach BINA RY PA C KIN G. Binary packing is closely related to Frame-Of-",
        "box": [
            93,
            68,
            500,
            79
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 240,
        "relation": "connect"
    },
    {
        "text": "Reference (FOR) [24] and it has been called PackedBinary [25].",
        "box": [
            93,
            80,
            357,
            91
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 243,
        "relation": "connect"
    },
    {
        "text": "Binary packing can be fast. Indeed, Catena et al. [1] found that it offered the best speed in a",
        "box": [
            103,
            92,
            500,
            102
        ],
        "class": "fstline",
        "page": 6,
        "is_meta": false,
        "parent_id": 239,
        "relation": "equality"
    },
    {
        "text": "search engine setting. Our fastest family of compression schemes is an instance of binary packing:",
        "box": [
            93,
            104,
            500,
            114
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 245,
        "relation": "connect"
    },
    {
        "text": "S 4-BP 12 8. The \u201cS4\u201d stands for 4-integer SIMD, \u201cBP\u201d stands for \u201cBinary Packing\u201d, and \u201c128\u201d",
        "box": [
            93,
            116,
            500,
            126
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 246,
        "relation": "connect"
    },
    {
        "text": "indicates the number of integers encoded in each block.",
        "box": [
            93,
            128,
            321,
            138
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 247,
        "relation": "connect"
    },
    {
        "text": "In the S 4-B P 1 28 format, we decompose arrays into meta-blocks of 2048 integers, each",
        "box": [
            103,
            140,
            500,
            150
        ],
        "class": "fstline",
        "page": 6,
        "is_meta": false,
        "parent_id": 245,
        "relation": "equality"
    },
    {
        "text": "containing 16 blocks of 128 integers. Before bit packing the 16 blocks, we write 16 bit widths (b)",
        "box": [
            93,
            152,
            500,
            162
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 249,
        "relation": "connect"
    },
    {
        "text": "using one byte each. For each block, the bit width is the smallest value b such that all corresponding",
        "box": [
            93,
            164,
            500,
            174
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 250,
        "relation": "connect"
    },
    {
        "text": "integers are smaller than 2b. The value b can range from 0 to 32. In practice, lists of integers are",
        "box": [
            93,
            175,
            500,
            186
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 251,
        "relation": "connect"
    },
    {
        "text": "rarely divisible by 2048. We handle remaining blocks of 128 integers separately. For each such",
        "box": [
            93,
            188,
            500,
            198
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 252,
        "relation": "connect"
    },
    {
        "text": "block, we write a byte containing a bit width b, followed by the corresponding 128 integers in bit",
        "box": [
            93,
            200,
            500,
            210
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 253,
        "relation": "connect"
    },
    {
        "text": "packed form. Finally, we compress the remaining integers (less than 128 integers) using VA R IN T.",
        "box": [
            93,
            212,
            491,
            222
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 254,
        "relation": "connect"
    },
    {
        "text": "4.4. FA S TP F O R, SIMD - FA S TP F O R, and S 4-FAST PFOR",
        "box": [
            93,
            240,
            340,
            251
        ],
        "class": "sec2",
        "page": 6,
        "is_meta": false,
        "parent_id": 238,
        "relation": "equality"
    },
    {
        "text": "The downside of the S 4-B P 1 28 approach is that the largest integers in a block of 128 integers",
        "box": [
            93,
            259,
            500,
            269
        ],
        "class": "fstline",
        "page": 6,
        "is_meta": false,
        "parent_id": 256,
        "relation": "contain"
    },
    {
        "text": "determine the compression ratio of all these integers. We could use smaller blocks (e.g., 32) to",
        "box": [
            93,
            271,
            500,
            281
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 257,
        "relation": "connect"
    },
    {
        "text": "improve compression. However, a better approach for performance might be patching [26] wherein",
        "box": [
            93,
            282,
            500,
            293
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 258,
        "relation": "connect"
    },
    {
        "text": "the block is first decompressed using a smaller bit width, and then a limited number of entries",
        "box": [
            93,
            294,
            500,
            305
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 259,
        "relation": "connect"
    },
    {
        "text": "requiring greater bit widths are overwritten (\u201cpatched\u201d) using additional information. That is,",
        "box": [
            93,
            306,
            500,
            317
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 260,
        "relation": "connect"
    },
    {
        "text": "instead of picking the bit width b such that all integers are smaller than 2b, we pick a different",
        "box": [
            93,
            317,
            500,
            329
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 261,
        "relation": "connect"
    },
    {
        "text": "bit width b\u2032 that might be smaller than b. That is, we only bit pack the least significant b\u2032 -bits from",
        "box": [
            93,
            329,
            500,
            341
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 262,
        "relation": "connect"
    },
    {
        "text": "each integer. We must still encode the missing information for all integers larger than or equal to",
        "box": [
            93,
            342,
            500,
            353
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 263,
        "relation": "connect"
    },
    {
        "text": "2b\u2032 : we call each such integer an exception.",
        "box": [
            93,
            352,
            270,
            365
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 264,
        "relation": "connect"
    },
    {
        "text": "In our version of patched coding (FAST PFOR, for \u201cfast patched frame-of-reference\u201d), we proceed",
        "box": [
            103,
            366,
            500,
            376
        ],
        "class": "fstline",
        "page": 6,
        "is_meta": false,
        "parent_id": 257,
        "relation": "equality"
    },
    {
        "text": "as in S4 - BP12 8, that is we bit pack blocks of 128 integers. To complement this data, we use a",
        "box": [
            93,
            378,
            500,
            388
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 266,
        "relation": "connect"
    },
    {
        "text": "metadata byte array. For each block, we store both bit widths b and b\u2032, as well as the number of",
        "box": [
            93,
            389,
            500,
            400
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 267,
        "relation": "connect"
    },
    {
        "text": "exceptions. Each location where an exception should be applied is also stored using one byte in",
        "box": [
            93,
            402,
            500,
            412
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 268,
        "relation": "connect"
    },
    {
        "text": "the metadata byte array. It remains to store the most significant b \u2212 b\u2032 bits of the integers larger",
        "box": [
            93,
            413,
            500,
            424
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 269,
        "relation": "connect"
    },
    {
        "text": "than or equal to 2b\u2032 . We collect these exceptions over many blocks (up to 512 blocks) and then bit",
        "box": [
            93,
            423,
            500,
            436
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 270,
        "relation": "connect"
    },
    {
        "text": "pack them together, into up to 32 bit packed arrays (one for each possible value of b \u2212 b\u2032 excluding",
        "box": [
            93,
            437,
            500,
            448
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 271,
        "relation": "connect"
    },
    {
        "text": "zero). For speed, these arrays are padded up to a multiple of 32 integers. The final data format is an",
        "box": [
            93,
            450,
            500,
            460
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 272,
        "relation": "connect"
    },
    {
        "text": "aggregation of the bit packed blocks (using b\u2032 bits per integer), the metadata byte array and the bit",
        "box": [
            93,
            461,
            500,
            472
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 273,
        "relation": "connect"
    },
    {
        "text": "packed arrays corresponding to the exceptions.",
        "box": [
            93,
            474,
            285,
            484
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 274,
        "relation": "connect"
    },
    {
        "text": "As an illustration, consider Fig. 3. We consider a block of 128 integers beginning with 1,2, 1,",
        "box": [
            103,
            486,
            500,
            496
        ],
        "class": "fstline",
        "page": 6,
        "is_meta": false,
        "parent_id": 266,
        "relation": "equality"
    },
    {
        "text": "134217729, 0. We assume that all values in the block except for 134217729 do not exceed three",
        "box": [
            93,
            498,
            500,
            508
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 276,
        "relation": "connect"
    },
    {
        "text": "and, thus, can be encooded using two bits each. In this case, we have that b = 27 and binary packing",
        "box": [
            93,
            510,
            500,
            520
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 277,
        "relation": "connect"
    },
    {
        "text": "would thus require 27 bits per integer\u2014even if most of the integers could fit in two bits. With",
        "box": [
            93,
            522,
            500,
            532
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 278,
        "relation": "connect"
    },
    {
        "text": "FAST PFOR, we might set b\u2032 = 2 and pack only the least significant two bits of each integer. To",
        "box": [
            93,
            532,
            500,
            544
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 279,
        "relation": "connect"
    },
    {
        "text": "allow decoding, we have to record that there is one exception at location 3 as well as the values of b",
        "box": [
            93,
            546,
            500,
            556
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 280,
        "relation": "connect"
    },
    {
        "text": "and b\u2032. Each of these numbers can be stored using one byte. We are left to code the b \u2212 b\u2032 = 25 most",
        "box": [
            93,
            556,
            500,
            568
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 281,
        "relation": "connect"
    },
    {
        "text": "significant bits of 134217729. We can store these bits in an array to be packed later. Once we",
        "box": [
            93,
            569,
            500,
            580
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 282,
        "relation": "connect"
    },
    {
        "text": "have processed many blocks of 128 integers, there might be several similar exceptions that need the",
        "box": [
            93,
            581,
            500,
            592
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 283,
        "relation": "connect"
    },
    {
        "text": "storage of their 25 most significant bits: they are stored and packed together. During decompression,",
        "box": [
            93,
            593,
            500,
            604
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 284,
        "relation": "connect"
    },
    {
        "text": "these most significant bits can be unpacked as needed from one of 32 different arrays (one for each",
        "box": [
            93,
            605,
            500,
            616
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 285,
        "relation": "connect"
    },
    {
        "text": "possible value of b \u2212 b\u2032 excluding zero).",
        "box": [
            93,
            616,
            258,
            628
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 286,
        "relation": "connect"
    },
    {
        "text": "Decompression using FAST PFOR is similar to decompression using S 4-B P 128, except that,",
        "box": [
            103,
            629,
            500,
            639
        ],
        "class": "fstline",
        "page": 6,
        "is_meta": false,
        "parent_id": 276,
        "relation": "equality"
    },
    {
        "text": "after bit unpacking the least significant b\u2032 bits for the integers of a block, we must proceed with the",
        "box": [
            93,
            640,
            500,
            651
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 288,
        "relation": "connect"
    },
    {
        "text": "patching. For this purpose, the packed arrays of exception values are unpacked as needed and we",
        "box": [
            93,
            653,
            500,
            663
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 289,
        "relation": "connect"
    },
    {
        "text": "loop over the exceptions.",
        "box": [
            93,
            665,
            196,
            675
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 290,
        "relation": "connect"
    },
    {
        "text": "The integer b is determined by the data\u2014as the number of bits required to store the largest integer",
        "box": [
            103,
            677,
            500,
            687
        ],
        "class": "fstline",
        "page": 6,
        "is_meta": false,
        "parent_id": 288,
        "relation": "equality"
    },
    {
        "text": "in the block. However, we are free to set b\u2032 to any integer in [0, b]. For each block, we pick b\u2032 to",
        "box": [
            93,
            688,
            500,
            699
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 292,
        "relation": "connect"
    },
    {
        "text": "minimize 128 \u00d7 b\u2032 + c(b\u2032 )(b \u2212 b\u2032 + 8) where c(b\u2032 ) is the number exceptions generated for a given",
        "box": [
            93,
            700,
            500,
            711
        ],
        "class": "para",
        "page": 6,
        "is_meta": false,
        "parent_id": 293,
        "relation": "connect"
    },
    {
        "text": "8",
        "box": [
            93,
            38,
            98,
            49
        ],
        "class": "header",
        "page": 7,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 7,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "1 2 1 134217729 0 2 1 1 0 \u00b7 \u00b7 \u00b7Input (128 integers, b = 27)1 2 1 1 0 2 1 1 0 \u00b7 \u00b7 \u00b7 The b \u2212 b\u2032 = 25 most significantbits of 134217729 are packedseparatelyb = 27 b\u2032 = 2 1 exception at position 3 \u00b7 \u00b7 \u00b7Array metadata (uses 4 bytes)Packed array (128b\u2032 bits)Pack lesserb\u2032 = 2 bits",
        "box": [
            127,
            65,
            457,
            220
        ],
        "class": "fig",
        "page": 7,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Figure 3. Example of compression using FASTPF OR (and S 4 -FASTP F O R). The data corresponding to a",
        "box": [
            93,
            232,
            500,
            241
        ],
        "class": "figcap",
        "page": 7,
        "is_meta": false,
        "parent_id": 297,
        "relation": "contain"
    },
    {
        "text": "block of 128 integers is located in a packed array (using b\u2032 bit per integer, in a metadata byte array and,",
        "box": [
            93,
            239,
            500,
            251
        ],
        "class": "opara",
        "page": 7,
        "is_meta": false,
        "parent_id": 298,
        "relation": "connect"
    },
    {
        "text": "finally, in a corresponding packed array of exceptions.",
        "box": [
            193,
            251,
            398,
            261
        ],
        "class": "opara",
        "page": 7,
        "is_meta": false,
        "parent_id": 299,
        "relation": "connect"
    },
    {
        "text": "value b\u2032 (e.g., c(b) = 0). This heuristic for picking b\u2032 can be computed quickly if we first tabulate",
        "box": [
            93,
            283,
            500,
            295
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 294,
        "relation": "connect"
    },
    {
        "text": "how many integers in the block are less than 2x for x = 0, . . . , b. For this purpose, we use the",
        "box": [
            93,
            295,
            500,
            307
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 301,
        "relation": "connect"
    },
    {
        "text": "assembly instruction bsr (Bit Scan Reverse) to calculate the log 2 of each integer.",
        "box": [
            93,
            308,
            428,
            320
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 302,
        "relation": "connect"
    },
    {
        "text": "We can compare FA S TP F O R with other patched schemes based on Lemire and Boytsov\u2019s",
        "box": [
            103,
            321,
            500,
            331
        ],
        "class": "fstline",
        "page": 7,
        "is_meta": false,
        "parent_id": 292,
        "relation": "equality"
    },
    {
        "text": "results [3]: the original scheme from Zukowski et al. [26] is faster than FAS TPF OR but has",
        "box": [
            93,
            332,
            500,
            343
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 304,
        "relation": "connect"
    },
    {
        "text": "worse compression ratios (even worse than the bit packing method S 4-B P 128 that does not use",
        "box": [
            93,
            344,
            500,
            355
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 305,
        "relation": "connect"
    },
    {
        "text": "patching), OptPFD [27] by Yan el al. sometimes compresses better than FA S TPF O R , but can be up",
        "box": [
            93,
            356,
            500,
            367
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 306,
        "relation": "connect"
    },
    {
        "text": "to two times slower, and their NewPFD [27] is typically slower and offers worse compression ratios",
        "box": [
            93,
            368,
            500,
            379
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 307,
        "relation": "connect"
    },
    {
        "text": "than FAST PFOR. A format inspired by FA S TPF O R (where bits from exceptions are bit packed)",
        "box": [
            93,
            380,
            500,
            391
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 308,
        "relation": "connect"
    },
    {
        "text": "is a part of the search engine Apache Lucene as of version 4.5.\u2020 In contrast, Catena et al. [1]",
        "box": [
            93,
            391,
            500,
            403
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 309,
        "relation": "connect"
    },
    {
        "text": "found that FAST PFOR provided no response time benefit compared to NewPFD and OptPFD when",
        "box": [
            93,
            404,
            500,
            414
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 310,
        "relation": "connect"
    },
    {
        "text": "compressing document identifiers. Possibly, the discrepancy can be explained by the fact that they",
        "box": [
            93,
            416,
            500,
            426
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 311,
        "relation": "connect"
    },
    {
        "text": "divided their arrays into small chunks of 1024 integers prior to compression. Indeed, FAST PFOR is",
        "box": [
            93,
            428,
            500,
            438
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 312,
        "relation": "connect"
    },
    {
        "text": "most effective when it is allowed to aggregate the exceptions over many blocks of 128 integers.",
        "box": [
            93,
            440,
            484,
            450
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 313,
        "relation": "connect"
    },
    {
        "text": "Because FA S TPF O R relies essentially on bit packing for compression, it is easy to vectorize it",
        "box": [
            103,
            452,
            500,
            462
        ],
        "class": "fstline",
        "page": 7,
        "is_meta": false,
        "parent_id": 304,
        "relation": "equality"
    },
    {
        "text": "using the same SIMD-based bit packing and unpacking functions used by S 4-B P 128 . We call the",
        "box": [
            93,
            464,
            500,
            474
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 315,
        "relation": "connect"
    },
    {
        "text": "resulting scheme S4- FA ST P F O R. In the original scheme by Lemire and Boytsov [3] (called SIM D -",
        "box": [
            93,
            476,
            499,
            486
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 316,
        "relation": "connect"
    },
    {
        "text": "FAST PFOR), the bit-packed exceptions were padded up to multiples of 128 integers instead of",
        "box": [
            93,
            488,
            500,
            498
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 317,
        "relation": "connect"
    },
    {
        "text": "multiples of 32 integers as in FA ST P F O R. While this insured that all memory pointers were aligned",
        "box": [
            93,
            500,
            500,
            510
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 318,
        "relation": "connect"
    },
    {
        "text": "on 16 bytes boundaries, it also adversely affected compression. Our S4 - FA S TPF O R has essentially",
        "box": [
            93,
            512,
            500,
            522
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 319,
        "relation": "connect"
    },
    {
        "text": "the same data format as FAST PFOR and, thus, the same compression ratios. These changes require",
        "box": [
            93,
            524,
            500,
            534
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 320,
        "relation": "connect"
    },
    {
        "text": "that we use (1) scalar bit packing/unpacking for up to 32 integers per packed array and (2) unaligned",
        "box": [
            93,
            536,
            500,
            546
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 321,
        "relation": "connect"
    },
    {
        "text": "load and store SIMD instructions. Neither of these differences significantly impacts performance,",
        "box": [
            93,
            548,
            500,
            558
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 322,
        "relation": "connect"
    },
    {
        "text": "and the compression ratios improve by \u22485 %.",
        "box": [
            93,
            560,
            280,
            570
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 323,
        "relation": "connect"
    },
    {
        "text": "5. DIFFERENTIAL CODING",
        "box": [
            232,
            597,
            360,
            608
        ],
        "class": "sec1",
        "page": 7,
        "is_meta": false,
        "parent_id": 174,
        "relation": "equality"
    },
    {
        "text": "Differential coding takes a sorted integer list x1 , x2, . . . and replaces it with successive",
        "box": [
            93,
            621,
            500,
            632
        ],
        "class": "fstline",
        "page": 7,
        "is_meta": false,
        "parent_id": 325,
        "relation": "contain"
    },
    {
        "text": "differences (or deltas) \u03b42 , \u03b43, . . . = x2 \u2212 x1 , x3 \u2212 x2 , . . .. If we keep the first value intact (x1 ), this",
        "box": [
            93,
            633,
            500,
            644
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 326,
        "relation": "connect"
    },
    {
        "text": "transformation is invertible. We can then apply various integer compression schemes on the deltas.",
        "box": [
            93,
            645,
            500,
            655
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 327,
        "relation": "connect"
    },
    {
        "text": "Since the deltas are smaller than the original integers in the list, we get better compression ratios.",
        "box": [
            93,
            657,
            491,
            667
        ],
        "class": "para",
        "page": 7,
        "is_meta": false,
        "parent_id": 328,
        "relation": "connect"
    },
    {
        "text": "\u2020 http://lucene.apache.org/core/4_9_0/core/org/apache/lucene/util/",
        "box": [
            93,
            692,
            422,
            701
        ],
        "class": "fnote",
        "page": 7,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "PForDeltaDocIdSet.html",
        "box": [
            93,
            702,
            205,
            710
        ],
        "class": "opara",
        "page": 7,
        "is_meta": true,
        "parent_id": 330,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 8,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "9",
        "box": [
            494,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 8,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Table II. Some of our terminology",
        "box": [
            232,
            66,
            361,
            75
        ],
        "class": "tabcap",
        "page": 8,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Differential coding Strategy to transform lists of sorted integers into listsof small integers by computing differences betweennearby, but not necessarily adjacent, integers. Weconsider four types of differential coding ( D 1, D2 ,DM, D4 ). To recover the initial array, it is necessaryto compute a prefix sum or its analog.Optionally, we can integrate differential coding in thepacking and unpacking. In such a case, unpackingincludes the computation of the prefix sum.pack (unpack) To encode (resp. decode) 32-bit integers to (resp.from) data blocks where all integers use a fixednumber of bits (bit width). Packing and unpackingroutines are used as part of integer compressionalgorithms such as binary packing.binary packing Compression scheme that packs blocks of integers(e.g., 128 integers) using as few bits as possible (e.g.,the S 4-B P 1 28 family)patched coding Compression strategy that uses binary packing toencode most of the data, while also encodingexceptions separately (e.g., the FAS TPFOR scheme)to improve the compression ratio.",
        "box": [
            121,
            86,
            469,
            361
        ],
        "class": "tab",
        "page": 8,
        "is_meta": false,
        "parent_id": 334,
        "relation": "contain"
    },
    {
        "text": "If the sorted lists contain no repetitions, we can further subtract one from all deltas as we know",
        "box": [
            103,
            383,
            500,
            393
        ],
        "class": "fstline",
        "page": 8,
        "is_meta": false,
        "parent_id": 326,
        "relation": "equality"
    },
    {
        "text": "that they are greater than zero. However, this only offers a significant benefit in compression if we",
        "box": [
            93,
            395,
            500,
            405
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 336,
        "relation": "connect"
    },
    {
        "text": "expect many of the deltas to be close to zero. And, in such cases, other schemes such as bit vectors",
        "box": [
            93,
            407,
            500,
            417
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 337,
        "relation": "connect"
    },
    {
        "text": "might be more appropriate. Thus, we do not consider this option any further.",
        "box": [
            93,
            419,
            407,
            429
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 338,
        "relation": "connect"
    },
    {
        "text": "Computing deltas during compression is an inexpensive operation that can be easily accelerated",
        "box": [
            103,
            431,
            500,
            441
        ],
        "class": "fstline",
        "page": 8,
        "is_meta": false,
        "parent_id": 336,
        "relation": "equality"
    },
    {
        "text": "with superscalar execution or even SIMD instructions. However, recovering the original list from the",
        "box": [
            93,
            443,
            500,
            453
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 340,
        "relation": "connect"
    },
    {
        "text": "deltas when decompressing can be more time consuming because of the inherent data-dependencies:",
        "box": [
            93,
            455,
            500,
            465
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 341,
        "relation": "connect"
    },
    {
        "text": "the value of each recovered integer can only be calculated after the value of the integer immediately",
        "box": [
            93,
            467,
            500,
            477
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 342,
        "relation": "connect"
    },
    {
        "text": "preceding it is known. Indeed, it involves the computation of a prefix sum: xi = xi\u22121 + \u03b4i . A naive",
        "box": [
            93,
            479,
            500,
            489
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 343,
        "relation": "connect"
    },
    {
        "text": "implementation could end up using one or more CPU cycles per integer just to calculate the prefix",
        "box": [
            93,
            491,
            500,
            501
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 344,
        "relation": "connect"
    },
    {
        "text": "sum. For a moderately fast scheme such as VA R IN T, this is not a concern, but for faster schemes,",
        "box": [
            93,
            502,
            500,
            513
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 345,
        "relation": "connect"
    },
    {
        "text": "computation of the prefix sum can become a performance bottleneck. To alleviate this problem, we",
        "box": [
            93,
            514,
            500,
            525
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 346,
        "relation": "connect"
    },
    {
        "text": "can sacrifice some compressibility, by computing the deltas on a four-by-four basis (henceforth D 4,",
        "box": [
            93,
            526,
            500,
            537
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 347,
        "relation": "connect"
    },
    {
        "text": "because it compares index differences of 4): \u03b4i = xi \u2212 xi\u22124 [3]. Although fast, this approach also",
        "box": [
            93,
            538,
            500,
            549
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 348,
        "relation": "connect"
    },
    {
        "text": "generates larger deltas.",
        "box": [
            93,
            550,
            187,
            561
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 349,
        "relation": "connect"
    },
    {
        "text": "As further refinements, we consider four different forms of differential coding that offer different",
        "box": [
            103,
            562,
            500,
            573
        ],
        "class": "fstline",
        "page": 8,
        "is_meta": false,
        "parent_id": 340,
        "relation": "equality"
    },
    {
        "text": "compression/speed trade-offs. Each form has a corresponding inverse\u2014for simplicity, we use the",
        "box": [
            93,
            574,
            500,
            584
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 351,
        "relation": "connect"
    },
    {
        "text": "term prefix sum to refer to all these inverse functions. As before, we assume 128-bit vectors and",
        "box": [
            93,
            586,
            500,
            596
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 352,
        "relation": "connect"
    },
    {
        "text": "process 32-bit integers.",
        "box": [
            93,
            598,
            188,
            608
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 353,
        "relation": "connect"
    },
    {
        "text": "\u2022 The fastest is D4 which computes the deltas four-by-four: e.g., (\u03b45 , \u03b46, \u03b47, \u03b48 ) = (x5 , x6 , x7, x8 ) \u2212",
        "box": [
            93,
            626,
            500,
            637
        ],
        "class": "fstline",
        "page": 8,
        "is_meta": false,
        "parent_id": 351,
        "relation": "equality"
    },
    {
        "text": "(x1 , x2, x3 , x4). We expect the deltas to be 4\u00d7 larger, which degrades the compression by",
        "box": [
            102,
            638,
            500,
            649
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 355,
        "relation": "connect"
    },
    {
        "text": "approximately two bits per integer. However, a single 1-cycle-latency SIMD instruction (paddd",
        "box": [
            102,
            649,
            500,
            660
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 356,
        "relation": "connect"
    },
    {
        "text": "in SSE2) can correctly calculate the prefix sum of four consecutive integers.",
        "box": [
            102,
            662,
            413,
            672
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 357,
        "relation": "connect"
    },
    {
        "text": "\u2022 The second fastest is DM . It is similar to D 4 except that instead of subtracting the previously",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "fstline",
        "page": 8,
        "is_meta": false,
        "parent_id": 355,
        "relation": "equality"
    },
    {
        "text": "decoded vector of integers, we subtract only the largest of these integers: \u03b44i+j = x4i+j \u2212 x4i\u22121 .",
        "box": [
            102,
            701,
            500,
            712
        ],
        "class": "para",
        "page": 8,
        "is_meta": false,
        "parent_id": 359,
        "relation": "connect"
    },
    {
        "text": "10",
        "box": [
            93,
            38,
            103,
            49
        ],
        "class": "header",
        "page": 9,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 9,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Table III. Comparison between the 4 vectorized differential coding techniques with 4-integer SIMD",
        "box": [
            93,
            66,
            500,
            75
        ],
        "class": "tabcap",
        "page": 9,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "instructions",
        "box": [
            274,
            76,
            318,
            85
        ],
        "class": "opara",
        "page": 9,
        "is_meta": false,
        "parent_id": 363,
        "relation": "connect"
    },
    {
        "text": "size of deltas instructions/intD1 1.0\u00d7 1.5D2 2.0\u00d7 1DM 2.5\u00d7 0.5D4 4.0\u00d7 0.25",
        "box": [
            211,
            96,
            381,
            157
        ],
        "class": "tab",
        "page": 9,
        "is_meta": false,
        "parent_id": 363,
        "relation": "contain"
    },
    {
        "text": "E.g.,",
        "box": [
            102,
            178,
            121,
            188
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 359,
        "relation": "equality"
    },
    {
        "text": "(\u03b45, \u03b46 , \u03b47 , \u03b48) = (x5, x6 , x7 , x8) \u2212 (x4, x4 , x4, x4).",
        "box": [
            196,
            199,
            405,
            210
        ],
        "class": "equ",
        "page": 9,
        "is_meta": false,
        "parent_id": 366,
        "relation": "connect"
    },
    {
        "text": "We expect the deltas to be 2.5\u00d7 larger on average. Compared to the computation of the prefix",
        "box": [
            105,
            221,
            500,
            231
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 366,
        "relation": "equality"
    },
    {
        "text": "sum with D 4, D M requires one extra instruction (pshufd in SSE2) to copy the last component",
        "box": [
            102,
            232,
            500,
            243
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 368,
        "relation": "connect"
    },
    {
        "text": "to all components: (x1 , . . . , x4) \u2192 (x4, . . . , x4 ). On Intel processors, the pshufd instruction is",
        "box": [
            102,
            244,
            500,
            256
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 369,
        "relation": "connect"
    },
    {
        "text": "fast.",
        "box": [
            102,
            257,
            119,
            267
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 370,
        "relation": "connect"
    },
    {
        "text": "\u2022 The third fastest is D2 : \u03b4i = xi \u2212 xi\u22122 . E.g.,",
        "box": [
            93,
            276,
            285,
            287
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 368,
        "relation": "equality"
    },
    {
        "text": "(\u03b45, \u03b46 , \u03b47 , \u03b48) = (x5, x6 , x7 , x8) \u2212 (x3, x4 , x5, x6).",
        "box": [
            196,
            298,
            405,
            309
        ],
        "class": "equ",
        "page": 9,
        "is_meta": false,
        "parent_id": 372,
        "relation": "connect"
    },
    {
        "text": "The deltas should be only 2\u00d7 larger on average. The prefix sum for D 2 can be implemented using",
        "box": [
            104,
            319,
            500,
            330
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 372,
        "relation": "equality"
    },
    {
        "text": "4 SIMD instructions.",
        "box": [
            102,
            331,
            188,
            342
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 374,
        "relation": "connect"
    },
    {
        "text": "1. Shift the delta vector by 2 integers (in SSE2 using pslldq): e.g., (\u03b45 , \u03b46, \u03b47 , \u03b48 ) \u2192",
        "box": [
            111,
            350,
            500,
            362
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 374,
        "relation": "equality"
    },
    {
        "text": "(0, 0, \u03b45, \u03b46).",
        "box": [
            124,
            363,
            175,
            374
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 376,
        "relation": "connect"
    },
    {
        "text": "2. Add the original delta vector with the shifted version: e.g., (\u03b45 , \u03b46 , \u03b45 + \u03b47, \u03b46 + \u03b48 ).",
        "box": [
            111,
            379,
            467,
            390
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 376,
        "relation": "equality"
    },
    {
        "text": "3. Select from the previous vector the last two integers and copy them twice (in SSE2 using",
        "box": [
            111,
            394,
            500,
            405
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 378,
        "relation": "equality"
    },
    {
        "text": "pshufd), e.g., (x1, x2 , x3, x4 ) \u2192 (x3, x4 , x3, x4 ).",
        "box": [
            124,
            406,
            330,
            417
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 379,
        "relation": "connect"
    },
    {
        "text": "4. Add the results of the last two operations.",
        "box": [
            111,
            422,
            294,
            432
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 379,
        "relation": "equality"
    },
    {
        "text": "\u2022 The slowest approach is D1 which is just the regular differential coding (\u03b4i = xi \u2212 xi\u22121 ).",
        "box": [
            93,
            442,
            500,
            453
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 381,
        "relation": "equality"
    },
    {
        "text": "It generates the smallest deltas. We compute it with a well-known approach using 6 SIMD",
        "box": [
            102,
            454,
            500,
            464
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 382,
        "relation": "connect"
    },
    {
        "text": "instructions.",
        "box": [
            102,
            466,
            152,
            476
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 383,
        "relation": "connect"
    },
    {
        "text": "1. The first two steps are as with D 2 to generate (\u03b45 , \u03b46, \u03b45 + \u03b47 , \u03b46 + \u03b48 ). Then we take this",
        "box": [
            111,
            486,
            500,
            496
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 382,
        "relation": "equality"
    },
    {
        "text": "result, shift it by one integer and add it to itself. Thus, we get:",
        "box": [
            124,
            498,
            376,
            508
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 385,
        "relation": "connect"
    },
    {
        "text": "(\u03b45, \u03b45 + \u03b46 , \u03b46 + \u03b45 + \u03b47, \u03b45 + \u03b46 + \u03b47 + \u03b48 ).",
        "box": [
            219,
            519,
            404,
            530
        ],
        "class": "equ",
        "page": 9,
        "is_meta": false,
        "parent_id": 386,
        "relation": "connect"
    },
    {
        "text": "2. We copy the last integer of the previous vector to all components of a new vector. Thus, we",
        "box": [
            111,
            556,
            500,
            566
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 385,
        "relation": "equality"
    },
    {
        "text": "generate (x4 , x4, x4, x4 ).",
        "box": [
            124,
            568,
            225,
            579
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 388,
        "relation": "connect"
    },
    {
        "text": "3. We add the last two results to get the final answer.",
        "box": [
            111,
            584,
            329,
            594
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 388,
        "relation": "equality"
    },
    {
        "text": "We summarize the different techniques ( D 1, D2 , D M, D4 ) in Table III. We stress that the",
        "box": [
            103,
            605,
            500,
            616
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 390,
        "relation": "equality"
    },
    {
        "text": "number of instructions is not a measure of running-time performance, if only because of superscalar",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 391,
        "relation": "connect"
    },
    {
        "text": "execution. Our analysis is for 4-integer SIMD instructions: for wider SIMD instructions, the number",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 392,
        "relation": "connect"
    },
    {
        "text": "of instructions per integer is smaller.",
        "box": [
            93,
            641,
            243,
            651
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 393,
        "relation": "connect"
    },
    {
        "text": "Combining a compression scheme like VARIN T and differential coding is not a problem. Since",
        "box": [
            103,
            653,
            500,
            663
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 391,
        "relation": "equality"
    },
    {
        "text": "we decode integers one at a time, we can easily integrate the computation of the prefix sum into the",
        "box": [
            93,
            665,
            500,
            675
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 395,
        "relation": "connect"
    },
    {
        "text": "decompression function: as soon as a new integer is decoded, it is added to the previous integer.",
        "box": [
            93,
            677,
            486,
            687
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 396,
        "relation": "connect"
    },
    {
        "text": "For S4 - BP12 8 and S 4-FAST PFOR, we could integrate differential coding at the block level.",
        "box": [
            103,
            689,
            500,
            699
        ],
        "class": "fstline",
        "page": 9,
        "is_meta": false,
        "parent_id": 395,
        "relation": "equality"
    },
    {
        "text": "That is, we could unpack 128 deltas and then calculate the prefix sum to convert these deltas back",
        "box": [
            93,
            701,
            500,
            711
        ],
        "class": "para",
        "page": 9,
        "is_meta": false,
        "parent_id": 398,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 10,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "11",
        "box": [
            489,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 10,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "to the original integers. Though the decompression requires two passes over the same small block",
        "box": [
            93,
            68,
            500,
            79
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 399,
        "relation": "connect"
    },
    {
        "text": "of integers, it is unlikely to cause many expensive cache misses.",
        "box": [
            93,
            80,
            355,
            91
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 402,
        "relation": "connect"
    },
    {
        "text": "Maybe surprisingly, we can do substantially better, at least for schemes such as S4 - BP1 2 8.",
        "box": [
            103,
            92,
            500,
            102
        ],
        "class": "fstline",
        "page": 10,
        "is_meta": false,
        "parent_id": 398,
        "relation": "equality"
    },
    {
        "text": "Instead of using two passes, we can use a single pass where we do both the bit unpacking and",
        "box": [
            93,
            104,
            500,
            114
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 404,
        "relation": "connect"
    },
    {
        "text": "the computation of the prefix sum. In some cases, the one-pass approach is almost twice as fast as",
        "box": [
            93,
            116,
            500,
            126
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 405,
        "relation": "connect"
    },
    {
        "text": "the two-pass approach.",
        "box": [
            93,
            128,
            187,
            138
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 406,
        "relation": "connect"
    },
    {
        "text": "Indeed, when unpacking a block of 128 integers, we store 32 SSE registers in memory. Such store",
        "box": [
            103,
            140,
            500,
            150
        ],
        "class": "fstline",
        "page": 10,
        "is_meta": false,
        "parent_id": 404,
        "relation": "equality"
    },
    {
        "text": "operations have a limited throughput of one per cycle on recent Intel processors [21]. However, if the",
        "box": [
            93,
            152,
            500,
            162
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 408,
        "relation": "connect"
    },
    {
        "text": "prefix sum computation is a separate step, we need to reload the recently unpacked data, compute",
        "box": [
            93,
            164,
            500,
            174
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 409,
        "relation": "connect"
    },
    {
        "text": "the prefix sum and then store the data again. In effect, we end up having to store 64 SSE registers",
        "box": [
            93,
            176,
            500,
            186
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 410,
        "relation": "connect"
    },
    {
        "text": "per block of 128 integers. Hence, we need at least 0.5 cycles to unpack an integer if the prefix sum",
        "box": [
            93,
            188,
            500,
            198
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 411,
        "relation": "connect"
    },
    {
        "text": "computation is separate. These store operations can become a bottleneck. A two-step unpacking has",
        "box": [
            93,
            200,
            500,
            210
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 412,
        "relation": "connect"
    },
    {
        "text": "a theoretical speed limit of 7.2 billion 32-bit integers per second on a 3.60 processor. Yet we can",
        "box": [
            93,
            212,
            500,
            222
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 413,
        "relation": "connect"
    },
    {
        "text": "nearly reach 9 billion 32-bit integers per second with a one-step unpacking (see \u00a7 7.4).",
        "box": [
            93,
            224,
            448,
            234
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 414,
        "relation": "connect"
    },
    {
        "text": "Henceforth we use the term unpacking to also refer to the process where we both unpack and",
        "box": [
            103,
            236,
            500,
            246
        ],
        "class": "fstline",
        "page": 10,
        "is_meta": false,
        "parent_id": 408,
        "relation": "equality"
    },
    {
        "text": "compute the prefix sum. Algorithm 1 illustrates the bit unpacking routine for a block of 128 integers.",
        "box": [
            93,
            248,
            500,
            258
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 416,
        "relation": "connect"
    },
    {
        "text": "It takes as a parameter a SIMD prefix-sum function P used at lines 10 and 16: for D 4, we",
        "box": [
            93,
            260,
            500,
            270
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 417,
        "relation": "connect"
    },
    {
        "text": "have P (t, v) = t + v (an element-wise addition of two vectors). Omitting lines 10 and 16 disables",
        "box": [
            93,
            272,
            500,
            282
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 418,
        "relation": "connect"
    },
    {
        "text": "differential coding. In practice, we generate one such function for each bit width b and for each",
        "box": [
            93,
            284,
            500,
            294
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 419,
        "relation": "connect"
    },
    {
        "text": "prefix-sum function P . The prefix sum always starts from an initial vector (v ). We set v = (0, 0, 0, 0)",
        "box": [
            93,
            295,
            500,
            306
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 420,
        "relation": "connect"
    },
    {
        "text": "initially and then, after decompressing each block of 128 integers, v is set to the last 4 integers",
        "box": [
            93,
            307,
            500,
            318
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 421,
        "relation": "connect"
    },
    {
        "text": "decoded.",
        "box": [
            93,
            319,
            130,
            330
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 422,
        "relation": "connect"
    },
    {
        "text": "Beside the integration of differential coding with the bit unpacking, we have also improved over",
        "box": [
            103,
            331,
            500,
            342
        ],
        "class": "fstline",
        "page": 10,
        "is_meta": false,
        "parent_id": 416,
        "relation": "equality"
    },
    {
        "text": "Lemire and Boytsov\u2019s bit unpacking [3, Fig. 7] in another way: whereas each of their procedures",
        "box": [
            93,
            343,
            500,
            354
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 424,
        "relation": "connect"
    },
    {
        "text": "may require several masks, our implementation uses a single mask per procedure (see line 4 in",
        "box": [
            93,
            355,
            500,
            366
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 425,
        "relation": "connect"
    },
    {
        "text": "Algorithm 1). Given that we only have 16 SIMD registers on our Intel processors, attempting to",
        "box": [
            93,
            367,
            500,
            377
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 426,
        "relation": "connect"
    },
    {
        "text": "keep several of them occupied with constant masks can be wasteful.",
        "box": [
            93,
            379,
            372,
            389
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 427,
        "relation": "connect"
    },
    {
        "text": "Unfortunately, for S 4-FAST P FOR, it is not clear how to integrate bit unpacking and computation",
        "box": [
            103,
            391,
            500,
            401
        ],
        "class": "fstline",
        "page": 10,
        "is_meta": false,
        "parent_id": 424,
        "relation": "equality"
    },
    {
        "text": "of the prefix sum. Indeed, S4 - FA S TPF O R requires three separate operations in sequence: bit",
        "box": [
            93,
            403,
            500,
            413
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 429,
        "relation": "connect"
    },
    {
        "text": "unpacking, patching and computing the prefix sum. Patching must happen after bit unpacking, but",
        "box": [
            93,
            415,
            500,
            425
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 430,
        "relation": "connect"
    },
    {
        "text": "before the prefix sum. This makes tight integration between patching and the prefix sum difficult:",
        "box": [
            93,
            427,
            500,
            437
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 431,
        "relation": "connect"
    },
    {
        "text": "we tried various approaches but they did not result in performance improvement.",
        "box": [
            93,
            439,
            424,
            449
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 432,
        "relation": "connect"
    },
    {
        "text": "6. FAST INTERSECTIONS",
        "box": [
            237,
            486,
            356,
            496
        ],
        "class": "sec1",
        "page": 10,
        "is_meta": false,
        "parent_id": 325,
        "relation": "equality"
    },
    {
        "text": "Consider lists of uncompressed integers. To compute the intersection between several sorted lists",
        "box": [
            93,
            510,
            500,
            520
        ],
        "class": "fstline",
        "page": 10,
        "is_meta": false,
        "parent_id": 434,
        "relation": "contain"
    },
    {
        "text": "quickly, a competitive approach is Set-vs-Set (SvS): we sort the lists in the order of non-decreasing",
        "box": [
            93,
            522,
            500,
            532
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 435,
        "relation": "connect"
    },
    {
        "text": "cardinality and intersect them two-by-two, starting with the smallest. A textbook intersection",
        "box": [
            93,
            534,
            500,
            544
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 436,
        "relation": "connect"
    },
    {
        "text": "algorithm between two lists (akin to the merge sort algorithm) runs in time O(m + n) where the",
        "box": [
            93,
            546,
            500,
            556
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 437,
        "relation": "connect"
    },
    {
        "text": "lists have length m and n (henceforth we call it S C AL AR). Though it is competitive when m and",
        "box": [
            93,
            557,
            500,
            568
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 438,
        "relation": "connect"
    },
    {
        "text": "n are similar, there are better alternatives when n \u226b m. Such alternative algorithms assume that",
        "box": [
            93,
            569,
            500,
            580
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 439,
        "relation": "connect"
    },
    {
        "text": "we intersect a small list r with a large list f . They iterate over the small list: for each element ri ,",
        "box": [
            93,
            581,
            500,
            592
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 440,
        "relation": "connect"
    },
    {
        "text": "they seek a match fj in the second list using some search procedure. Whether there is a match or",
        "box": [
            93,
            593,
            500,
            604
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 441,
        "relation": "connect"
    },
    {
        "text": "not, they advance in the second list up to the first point where the value is at least as large as the",
        "box": [
            93,
            605,
            500,
            616
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 442,
        "relation": "connect"
    },
    {
        "text": "one in the small list (fj \u2265 ri ). The search procedure assumes that the lists are sorted so it can skip",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 443,
        "relation": "connect"
    },
    {
        "text": "values. A popular algorithm uses galloping search [28] (also called exponential search): we pick",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 444,
        "relation": "connect"
    },
    {
        "text": "the next available integer ri from the small list and seek an integer at least as large in the other list,",
        "box": [
            93,
            641,
            500,
            652
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 445,
        "relation": "connect"
    },
    {
        "text": "looking first at the next available value, then looking twice as far, and so on. We keep doubling the",
        "box": [
            93,
            653,
            500,
            663
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 446,
        "relation": "connect"
    },
    {
        "text": "distance until we find the first integer fj \u2265 ri that is not smaller than ri. Then, we use binary search",
        "box": [
            93,
            665,
            500,
            676
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 447,
        "relation": "connect"
    },
    {
        "text": "to advance in the second list to the first value larger than or equal to ri. The binary search range",
        "box": [
            93,
            677,
            500,
            688
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 448,
        "relation": "connect"
    },
    {
        "text": "is from the current position to the position of value fj . Computing galloping intersections requires",
        "box": [
            93,
            689,
            500,
            700
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 449,
        "relation": "connect"
    },
    {
        "text": "only O (m log n) time which is better than O(m + n) when n \u226b m.",
        "box": [
            93,
            701,
            370,
            711
        ],
        "class": "para",
        "page": 10,
        "is_meta": false,
        "parent_id": 450,
        "relation": "connect"
    },
    {
        "text": "12",
        "box": [
            93,
            38,
            103,
            49
        ],
        "class": "header",
        "page": 11,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 11,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Algorithm 1 Unpacking procedure using 128-bit vectors with integrated differential coding. We",
        "box": [
            93,
            68,
            500,
            78
        ],
        "class": "tabcap",
        "page": 11,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "write \u226b for the bitwise zero-fill right shift, \u226a for the bitwise left shift, & for the bitwise AND, and |",
        "box": [
            93,
            80,
            500,
            90
        ],
        "class": "opara",
        "page": 11,
        "is_meta": false,
        "parent_id": 454,
        "relation": "connect"
    },
    {
        "text": "for the bitwise OR. The binary function P depends on the type of differential coding (e.g., to disable",
        "box": [
            93,
            92,
            500,
            102
        ],
        "class": "opara",
        "page": 11,
        "is_meta": false,
        "parent_id": 455,
        "relation": "connect"
    },
    {
        "text": "differential coding set P (t, v) = t).",
        "box": [
            93,
            104,
            237,
            114
        ],
        "class": "opara",
        "page": 11,
        "is_meta": false,
        "parent_id": 456,
        "relation": "connect"
    },
    {
        "text": "1: input: a bit width b, a list of 32-bit integers y1 , y2 , . . . , yb , prefix-sum seed vector v2: output: list of 128 32-bit integers in [0, 2b )3: w \u2190 empty list4: M \u2190 (2b \u2212 1, 2b \u2212 1, 2b \u2212 1, 2b \u2212 1) {Reusable mask}5: i \u2190 06: for k = 0, 1, . . . , b \u2212 1 do7: while i + b \u2264 32 do8: t \u2190 (y1+4k \u226b i, y2+4k \u226b i, y3+4k \u226b i, y4+4k \u226b i)9: t \u2190 t & M {Bitwise AND with mask}10: t \u2190 P (t, v) and v \u2190 t {Prefix sum}11: append integers t1 , t2, t3 , t4 to list w12: i \u2190 i + b13: if i < 32 then14: z \u2190(y5+4k \u226a 32 \u2212 i, y6+4k \u226a 32 \u2212 i,y7+4k \u226a 32 \u2212 i, y8+4k \u226a 32 \u2212 i) & M15: t \u2190(y1+4k \u226b i, y2+4k \u226b i,y3+4k \u226b i, y4+4k \u226b i) | z16: t \u2190 P (t, v) and v \u2190 t {Prefix sum}17: append integers t1 , t2, t3 , t4 to list w18: i \u2190 i + b \u2212 3219: else20: i \u2190 021: return w",
        "box": [
            95,
            115,
            501,
            403
        ],
        "class": "tab",
        "page": 11,
        "is_meta": false,
        "parent_id": 454,
        "relation": "contain"
    },
    {
        "text": "6.1. Existing SIMD intersection algorithms",
        "box": [
            93,
            424,
            272,
            434
        ],
        "class": "sec2",
        "page": 11,
        "is_meta": false,
        "parent_id": 434,
        "relation": "contain"
    },
    {
        "text": "Though there is much related work [29], we could find only two algorithms for the computation of",
        "box": [
            93,
            442,
            500,
            452
        ],
        "class": "fstline",
        "page": 11,
        "is_meta": false,
        "parent_id": 459,
        "relation": "contain"
    },
    {
        "text": "intersections over sorted uncompressed lists of integers using SIMD instructions.",
        "box": [
            93,
            454,
            425,
            464
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 460,
        "relation": "connect"
    },
    {
        "text": "1. Schlegel et al. [30] use a specialized data structure, where integers are partitioned into sub-",
        "box": [
            105,
            475,
            500,
            485
        ],
        "class": "fstline",
        "page": 11,
        "is_meta": false,
        "parent_id": 460,
        "relation": "equality"
    },
    {
        "text": "arrays of integers having the same 16 most significant bits. To represent sub-array values, one",
        "box": [
            118,
            487,
            500,
            497
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 462,
        "relation": "connect"
    },
    {
        "text": "needs 16 bits for each sub-array element plus 16 bits to represent the most significant bytes",
        "box": [
            118,
            499,
            500,
            509
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 463,
        "relation": "connect"
    },
    {
        "text": "shared among all the integers.",
        "box": [
            118,
            511,
            241,
            521
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 464,
        "relation": "connect"
    },
    {
        "text": "To compute the intersection between two lists, Schlegel et al. iterate over all pairs of 16-bit",
        "box": [
            118,
            528,
            500,
            538
        ],
        "class": "fstline",
        "page": 11,
        "is_meta": false,
        "parent_id": 462,
        "relation": "equality"
    },
    {
        "text": "sub-arrays (from the first and the second list, respectively) with identical 16 most significant",
        "box": [
            118,
            540,
            500,
            550
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 466,
        "relation": "connect"
    },
    {
        "text": "bits. In each iteration, they compute the intersection over two 16-bit arrays. To this end, each",
        "box": [
            118,
            552,
            500,
            562
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 467,
        "relation": "connect"
    },
    {
        "text": "sub-array is logically divided into blocks each containing eight 16-bit integers. For simplicity,",
        "box": [
            118,
            564,
            500,
            574
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 468,
        "relation": "connect"
    },
    {
        "text": "we assume that the number of integers is a multiple of eight. In practice, lists may contain a",
        "box": [
            118,
            576,
            500,
            586
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 469,
        "relation": "connect"
    },
    {
        "text": "number of integers that is not divisible by eight. However, one can terminate the computation",
        "box": [
            118,
            588,
            500,
            598
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 470,
        "relation": "connect"
    },
    {
        "text": "of the intersection with the few remaining integers and process these integers using a more",
        "box": [
            118,
            600,
            500,
            610
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 471,
        "relation": "connect"
    },
    {
        "text": "traditional intersection algorithm.",
        "box": [
            118,
            612,
            256,
            622
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 472,
        "relation": "connect"
    },
    {
        "text": "The intersection algorithm can be seen as a generalization of the textbook intersection",
        "box": [
            118,
            629,
            500,
            639
        ],
        "class": "fstline",
        "page": 11,
        "is_meta": false,
        "parent_id": 466,
        "relation": "equality"
    },
    {
        "text": "algorithm (akin to the merge sort algorithm). There are two block pointers (one for each",
        "box": [
            118,
            641,
            500,
            651
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 474,
        "relation": "connect"
    },
    {
        "text": "sub-array) originally pointing to the first blocks. Using SIMD instructions, it is possible to",
        "box": [
            118,
            653,
            500,
            663
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 475,
        "relation": "connect"
    },
    {
        "text": "carry out an all-against-all comparison of 16-bit integers between these two blocks and extract",
        "box": [
            118,
            665,
            500,
            675
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 476,
        "relation": "connect"
    },
    {
        "text": "matching integers. Schlegel et al. exploit the fact that such a comparison can quickly be done",
        "box": [
            118,
            677,
            500,
            687
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 477,
        "relation": "connect"
    },
    {
        "text": "using the SSE 4.1 string-comparison instruction pcmpestrm. (See \u00a7 3.) Recall that this",
        "box": [
            118,
            688,
            500,
            699
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 478,
        "relation": "connect"
    },
    {
        "text": "instruction takes strings of up to eight 16-bit integers and returns an 8-bit mask indicating",
        "box": [
            118,
            701,
            500,
            711
        ],
        "class": "para",
        "page": 11,
        "is_meta": false,
        "parent_id": 479,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 12,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "13",
        "box": [
            489,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 12,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "which 16-bit integers are present in both strings. The number of 1s in the resulting mask",
        "box": [
            118,
            68,
            500,
            79
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 480,
        "relation": "connect"
    },
    {
        "text": "(computed quickly with the popcnt instruction) indicates the number of matching integers.",
        "box": [
            118,
            80,
            500,
            91
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 483,
        "relation": "connect"
    },
    {
        "text": "Schlegel et al. apply this instruction to two blocks of eight integers (one from the first list",
        "box": [
            118,
            92,
            500,
            102
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 484,
        "relation": "connect"
    },
    {
        "text": "and another from the second list). To obtain matching integers, they use the shuffle SSSE3",
        "box": [
            118,
            104,
            500,
            114
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 485,
        "relation": "connect"
    },
    {
        "text": "instruction pshufb. This instruction extracts and juxtaposes matching integers so that they",
        "box": [
            118,
            115,
            500,
            126
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 486,
        "relation": "connect"
    },
    {
        "text": "follow each other without gaps. This requires a lookup table to convert 8-bit masks produced",
        "box": [
            118,
            128,
            500,
            138
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 487,
        "relation": "connect"
    },
    {
        "text": "by pcmpestrm (and extracted using pextrd) to the shuffle mask for pshufb. The lookup",
        "box": [
            118,
            139,
            500,
            150
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 488,
        "relation": "connect"
    },
    {
        "text": "table contains 256 128-bit shuffle masks. The matching integers are written out and the output",
        "box": [
            118,
            152,
            500,
            162
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 489,
        "relation": "connect"
    },
    {
        "text": "pointer is advanced by the number of matching integers.",
        "box": [
            118,
            164,
            349,
            174
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 490,
        "relation": "connect"
    },
    {
        "text": "Afterwards, the highest values of the two blocks are compared. If the highest value in the",
        "box": [
            118,
            180,
            500,
            190
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 474,
        "relation": "equality"
    },
    {
        "text": "first block is smaller than the highest value of the second block, the first block pointer is",
        "box": [
            118,
            192,
            500,
            202
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 492,
        "relation": "connect"
    },
    {
        "text": "advanced. If the second block contains a smaller highest value, its pointer is advanced in a",
        "box": [
            118,
            204,
            500,
            214
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 493,
        "relation": "connect"
    },
    {
        "text": "similar fashion. If the highest values are equal, the block pointers of both lists are advanced.",
        "box": [
            118,
            216,
            500,
            226
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 494,
        "relation": "connect"
    },
    {
        "text": "When the blocks in one of the lists are exhausted, the intersection has been computed.",
        "box": [
            118,
            228,
            471,
            238
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 495,
        "relation": "connect"
    },
    {
        "text": "We slightly improved Schlegel et al.\u2019s implementation by replacing the pcmpestrm",
        "box": [
            118,
            243,
            500,
            254
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 492,
        "relation": "equality"
    },
    {
        "text": "instruction with the similar pcmpistrm instruction. The latter is faster. Its only downside",
        "box": [
            118,
            255,
            500,
            266
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 497,
        "relation": "connect"
    },
    {
        "text": "is that it assumes that the two strings of 16-bit characters are either null terminated or have",
        "box": [
            118,
            267,
            500,
            278
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 498,
        "relation": "connect"
    },
    {
        "text": "a length of 8 characters. However, because the integers are sorted (even in 16-bit packed",
        "box": [
            118,
            279,
            500,
            289
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 499,
        "relation": "connect"
    },
    {
        "text": "blocks), we can easily check for the presence of a zero 16-bit integer as a special case.",
        "box": [
            118,
            291,
            472,
            301
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 500,
        "relation": "connect"
    },
    {
        "text": "Schlegel et al. only validated their results on the intersection of arrays that have identical",
        "box": [
            118,
            307,
            500,
            317
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 497,
        "relation": "equality"
    },
    {
        "text": "lengths. In contrast, we work on arrays of 32-bit integers having differing lengths.",
        "box": [
            118,
            319,
            454,
            329
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 502,
        "relation": "connect"
    },
    {
        "text": "2. Katsov [31] proposed an approach similar to Schlegel et al. except that it works on arrays",
        "box": [
            105,
            339,
            500,
            349
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 502,
        "relation": "equality"
    },
    {
        "text": "of 32-bit integers. We process the input arrays by considering blocks of four 32-bit integers.",
        "box": [
            118,
            351,
            500,
            361
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 504,
        "relation": "connect"
    },
    {
        "text": "Given two blocks (a, b, c, d) and (a\u2032, b\u2032 , c\u2032, d\u2032 ), we execute four comparisons:",
        "box": [
            118,
            361,
            431,
            373
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 505,
        "relation": "connect"
    },
    {
        "text": "\u2022 (a, b, c, d) = (a\u2032, b\u2032 , c\u2032, d\u2032 ),",
        "box": [
            131,
            381,
            247,
            392
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 504,
        "relation": "equality"
    },
    {
        "text": "\u2022 (a, b, c, d) = (b\u2032, c\u2032 , d\u2032, a\u2032 ),",
        "box": [
            131,
            397,
            247,
            408
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 507,
        "relation": "equality"
    },
    {
        "text": "\u2022 (a, b, c, d) = (c\u2032, d\u2032 , a\u2032, b\u2032 ),",
        "box": [
            131,
            412,
            247,
            424
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 508,
        "relation": "equality"
    },
    {
        "text": "\u2022 (a, b, c, d) = (d\u2032, a\u2032 , b\u2032, c\u2032 ).",
        "box": [
            131,
            428,
            247,
            439
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 509,
        "relation": "equality"
    },
    {
        "text": "For each comparison, the pcmpeqd instruction generates four integers with value",
        "box": [
            118,
            448,
            500,
            459
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 510,
        "relation": "equality"
    },
    {
        "text": "0xFFFFFFFF or 0 depending on whether the corresponding pairs of integers are equal. By",
        "box": [
            118,
            461,
            500,
            471
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 511,
        "relation": "connect"
    },
    {
        "text": "computing the bitwise OR of the 4 resulting masks, we know whether each value in (a, b, c, d)",
        "box": [
            118,
            473,
            500,
            483
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 512,
        "relation": "connect"
    },
    {
        "text": "matches one value in (a\u2032 , b\u2032, c\u2032 , d\u2032). We can extract the corresponding 4-bit mask with the",
        "box": [
            118,
            483,
            500,
            495
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 513,
        "relation": "connect"
    },
    {
        "text": "movmskps instruction. The rest is similar to Schlegel et al.\u2019s algorithm.",
        "box": [
            118,
            496,
            415,
            507
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 514,
        "relation": "connect"
    },
    {
        "text": "There has been extensive work to accelerate sort or search algorithms by using SIMD",
        "box": [
            103,
            516,
            500,
            526
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 511,
        "relation": "equality"
    },
    {
        "text": "instructions [32, 33], among others. Nevertheless, we are not aware of other algorithms practically",
        "box": [
            93,
            528,
            500,
            538
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 516,
        "relation": "connect"
    },
    {
        "text": "relevant to the intersection of sorted lists of integers using SIMD instructions.",
        "box": [
            93,
            540,
            412,
            550
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 517,
        "relation": "connect"
    },
    {
        "text": "6.2. Our intersection algorithms",
        "box": [
            93,
            563,
            228,
            573
        ],
        "class": "sec2",
        "page": 12,
        "is_meta": false,
        "parent_id": 459,
        "relation": "equality"
    },
    {
        "text": "Both the SvS and textbook algorithms involve checking whether an element from one list is in the",
        "box": [
            93,
            581,
            500,
            592
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 519,
        "relation": "contain"
    },
    {
        "text": "other list. When one list is substantially shorter than the other, we typically compare a single integer",
        "box": [
            93,
            593,
            500,
            604
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 520,
        "relation": "connect"
    },
    {
        "text": "from the shorter list against several adjacent integers from the longer list. Such comparisons can be",
        "box": [
            93,
            605,
            500,
            616
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 521,
        "relation": "connect"
    },
    {
        "text": "efficiently done using SIMD operations (see sample code in Appendix A) and this is the underlying",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 522,
        "relation": "connect"
    },
    {
        "text": "idea of our intersection algorithms. Unlike the algorithms by Schlegel et al. and Katsov we do not",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 523,
        "relation": "connect"
    },
    {
        "text": "need to process a mask to determine which integers intersect since we check only one integer at a",
        "box": [
            93,
            641,
            500,
            651
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 524,
        "relation": "connect"
    },
    {
        "text": "time from the short list.",
        "box": [
            93,
            653,
            190,
            663
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 525,
        "relation": "connect"
    },
    {
        "text": "When implementing the SvS algorithm over uncompressed integers, it is convenient to be able",
        "box": [
            103,
            665,
            500,
            675
        ],
        "class": "fstline",
        "page": 12,
        "is_meta": false,
        "parent_id": 520,
        "relation": "equality"
    },
    {
        "text": "to write out the result of the intersection directly in one of the two lists. This removes the need to",
        "box": [
            93,
            677,
            500,
            687
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 527,
        "relation": "connect"
    },
    {
        "text": "allocate additional memory to save the result of the intersection. All our intersection algorithms are",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 528,
        "relation": "connect"
    },
    {
        "text": "designed to have the output-to-input property: it is always safe to write the result in the shorter of",
        "box": [
            93,
            701,
            500,
            711
        ],
        "class": "para",
        "page": 12,
        "is_meta": false,
        "parent_id": 529,
        "relation": "connect"
    },
    {
        "text": "14",
        "box": [
            93,
            38,
            103,
            49
        ],
        "class": "header",
        "page": 13,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 13,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "the two lists, because the algorithms never overwrite unprocessed data. The algorithms by Schlegel",
        "box": [
            93,
            68,
            500,
            79
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 530,
        "relation": "connect"
    },
    {
        "text": "et al. and Katsov do not have this property.",
        "box": [
            93,
            80,
            269,
            91
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 533,
        "relation": "connect"
    },
    {
        "text": "Our simplest SIMD intersection algorithm is V1 (see Algorithm 2): V 1 stands for \u201cfirst vectorized",
        "box": [
            103,
            92,
            500,
            102
        ],
        "class": "fstline",
        "page": 13,
        "is_meta": false,
        "parent_id": 527,
        "relation": "equality"
    },
    {
        "text": "intersection algorithm\u201d. It is essentially equivalent to a simple textbook intersection algorithm",
        "box": [
            93,
            104,
            500,
            114
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 535,
        "relation": "connect"
    },
    {
        "text": "( S C AL AR) except that we access the integers of the long lists in blocks of T integers. We advance in",
        "box": [
            93,
            116,
            500,
            126
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 536,
        "relation": "connect"
    },
    {
        "text": "the short list one integer at a time. We then advance in the long list until we find a block of T integers",
        "box": [
            93,
            128,
            500,
            138
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 537,
        "relation": "connect"
    },
    {
        "text": "such that the last one is at least as large as the integer in the short list. We compare the block of",
        "box": [
            93,
            140,
            500,
            150
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 538,
        "relation": "connect"
    },
    {
        "text": "T different integers in the long list with the integer in the short list using SIMD instructions. If there",
        "box": [
            93,
            152,
            500,
            162
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 539,
        "relation": "connect"
    },
    {
        "text": "is a match, that is, if one of the T integers is equal to the integer from the short list, we append that",
        "box": [
            93,
            164,
            500,
            174
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 540,
        "relation": "connect"
    },
    {
        "text": "integer to the intersection list.",
        "box": [
            93,
            176,
            215,
            186
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 541,
        "relation": "connect"
    },
    {
        "text": "For example, consider Fig. 4. In the short list r , we want to know whether the integer 23 is",
        "box": [
            103,
            188,
            500,
            198
        ],
        "class": "fstline",
        "page": 13,
        "is_meta": false,
        "parent_id": 535,
        "relation": "equality"
    },
    {
        "text": "present in the longer list. We start by creating a vector containing T = 8 copies of the integer:",
        "box": [
            93,
            200,
            500,
            210
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 543,
        "relation": "connect"
    },
    {
        "text": "R = (23, 23, . . . , 23). From the long list, we load 8 consecutive integers such that the last integer in",
        "box": [
            93,
            212,
            500,
            222
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 544,
        "relation": "connect"
    },
    {
        "text": "the list is at least as large as 23. In this case, we load F = (15, 16, . . . , 29, 31). Then we compare the",
        "box": [
            93,
            224,
            500,
            234
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 545,
        "relation": "connect"
    },
    {
        "text": "vectors R and F using as little as two SIMD operations. In our example, there is a match. There is",
        "box": [
            93,
            236,
            500,
            246
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 546,
        "relation": "connect"
    },
    {
        "text": "no need to do much further work: we have determined that the integer r belongs to the intersection.",
        "box": [
            93,
            248,
            500,
            258
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 547,
        "relation": "connect"
    },
    {
        "text": "Algorithm 2 The V 1 intersection algorithmRequire: SIMD architecture with T-integer vectors1: input: two sorted non-empty arrays of integers r, f2: assume: length(f ) is divisible by T3: x initially empty dynamic array (our answer)4: j \u2190 15: for i \u2208 {1, 2, . . . , length(r)} do6: R \u2190 (ri, ri , . . . , ri)7: while fj\u22121+T < ri do8: j \u2190 j + T9: if j > length(f ) then10: return x11: F \u2190 (fj , fj +1, . . . , fj\u22121+T)12: if Ri = Fi for some i \u2208 {1, 2, . . . , T} then13: append ri to x14: return x",
        "box": [
            93,
            277,
            503,
            479
        ],
        "class": "tab",
        "page": 13,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "We found it best to use the V1 algorithm with T = 8. Because SSE2 only offers 4-integer vectors,",
        "box": [
            103,
            498,
            500,
            508
        ],
        "class": "fstline",
        "page": 13,
        "is_meta": false,
        "parent_id": 543,
        "relation": "equality"
    },
    {
        "text": "we simulate an 8-integer vector by using two 4-integer vectors (see Appendix A). To compare two",
        "box": [
            93,
            510,
            500,
            520
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 550,
        "relation": "connect"
    },
    {
        "text": "vectors for possible equality between any two components, we use the pcmpeqd instruction: given",
        "box": [
            93,
            521,
            500,
            532
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 551,
        "relation": "connect"
    },
    {
        "text": "4 pairs of 32-bit integers, it generates 4 integers: 0xFFFFFFFF when the two integers are equal and",
        "box": [
            93,
            533,
            500,
            544
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 552,
        "relation": "connect"
    },
    {
        "text": "0x00000000 otherwise. We can combine the result of two such tests with a bitwise OR (por). To",
        "box": [
            93,
            545,
            500,
            556
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 553,
        "relation": "connect"
    },
    {
        "text": "test whether there is a match of any of the integers, we use the movmskps instruction.",
        "box": [
            93,
            557,
            449,
            568
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 554,
        "relation": "connect"
    },
    {
        "text": "However, the computational complexity of the V1 algorithm is still O(m + n/T) where T is",
        "box": [
            103,
            569,
            500,
            580
        ],
        "class": "fstline",
        "page": 13,
        "is_meta": false,
        "parent_id": 550,
        "relation": "equality"
    },
    {
        "text": "limited to small constants by the CPU architecture. Hence, a simple galloping intersection can be",
        "box": [
            93,
            581,
            500,
            592
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 556,
        "relation": "connect"
    },
    {
        "text": "faster than V1 when n \u226b m as the galloping algorithm has complexity O(m log n).",
        "box": [
            93,
            593,
            435,
            604
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 557,
        "relation": "connect"
    },
    {
        "text": "We can optimize further and add two layers of branching (henceforth V 3, see Algorithm 3). That",
        "box": [
            103,
            605,
            500,
            616
        ],
        "class": "fstline",
        "page": 13,
        "is_meta": false,
        "parent_id": 556,
        "relation": "equality"
    },
    {
        "text": "is, like with V 1, we first locate a block of 4T integers (fj, . . . , fj\u22121+4T ) in the larger array f where",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 559,
        "relation": "connect"
    },
    {
        "text": "a match could be found for the current value ri selected from the small array: we increment j by",
        "box": [
            93,
            629,
            500,
            640
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 560,
        "relation": "connect"
    },
    {
        "text": "steps of 4T until the last value from the current block is at least as large as the value from the small",
        "box": [
            93,
            641,
            500,
            651
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 561,
        "relation": "connect"
    },
    {
        "text": "array, fj \u22121+4T \u2265 ri. However, instead of directly comparing 4T pairs of integers as the analog",
        "box": [
            93,
            653,
            500,
            664
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 562,
        "relation": "connect"
    },
    {
        "text": "of Algorithm V1 would do, we use the binary search algorithm to find the one block of T integers",
        "box": [
            93,
            665,
            500,
            675
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 563,
        "relation": "connect"
    },
    {
        "text": "within the larger block of 4T integers where a match is possible. Technically, we compare the current",
        "box": [
            93,
            677,
            500,
            687
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 564,
        "relation": "connect"
    },
    {
        "text": "value from the small array ri with the value in the middle of the block of 4T (integers fj\u22121+2T ) and",
        "box": [
            93,
            689,
            500,
            700
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 565,
        "relation": "connect"
    },
    {
        "text": "then again with either the value in the middle of the first half (fj\u22121+T ) or in the middle of the second",
        "box": [
            93,
            701,
            500,
            712
        ],
        "class": "para",
        "page": 13,
        "is_meta": false,
        "parent_id": 566,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 14,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "15",
        "box": [
            489,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 14,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "r112235671 \u2212\u2192 R2323232323232323(a) Extract one value ri from r andcreate T-integer vector filled with thisone value R = (ri, ri , . . .) (e.g., withthe pshufd SSE2 instruction) f151620222327293132... \u2212\u2192 F1516202223272931(b) Load T values from f in vectorF (e.g., using the movdqu SSE2instruction)R2323232323232323 = F1516202223272931(c) Determine whether Ri = Fi forsome i (e.g., using the pcmpeqdand movmskps instructions)",
        "box": [
            151,
            76,
            447,
            379
        ],
        "class": "fig",
        "page": 14,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Figure 4. Brief illustration of Algorithm V1 with T = 8 and ri = 23",
        "box": [
            167,
            386,
            426,
            397
        ],
        "class": "figcap",
        "page": 14,
        "is_meta": false,
        "parent_id": 570,
        "relation": "contain"
    },
    {
        "text": "half (fj\u22121+3T ). Thus, some comparisons can be skipped. We first tried a version, called V 2, that",
        "box": [
            93,
            419,
            500,
            430
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 567,
        "relation": "connect"
    },
    {
        "text": "added only one layer of branching to V 1 but it did not prove useful in practice.",
        "box": [
            93,
            431,
            417,
            441
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 572,
        "relation": "connect"
    },
    {
        "text": "However, when n is large, galloping is superior to both V1 and V3. Thus, we also created a",
        "box": [
            103,
            443,
            500,
            453
        ],
        "class": "fstline",
        "page": 14,
        "is_meta": false,
        "parent_id": 559,
        "relation": "equality"
    },
    {
        "text": "SIMD-based galloping (henceforth S I MD GA LL OPI NG, see Algorithm 4). It uses the same ideas",
        "box": [
            93,
            455,
            500,
            465
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 574,
        "relation": "connect"
    },
    {
        "text": "as galloping search, except that we exploit the fact that SIMD instructions can compare T pairs of",
        "box": [
            93,
            467,
            500,
            477
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 575,
        "relation": "connect"
    },
    {
        "text": "integers at once. S I MD G A L LOP I NG has similar complexity in terms of m and n as scalar galloping",
        "box": [
            93,
            479,
            500,
            489
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 576,
        "relation": "connect"
    },
    {
        "text": "(O( mT log n) = O(m log n)) so we expect good scalability.",
        "box": [
            93,
            490,
            332,
            504
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 577,
        "relation": "connect"
    },
    {
        "text": "6.2.1. SIMD Hybrid Algorithm",
        "box": [
            93,
            516,
            224,
            526
        ],
        "class": "sec3",
        "page": 14,
        "is_meta": false,
        "parent_id": 519,
        "relation": "contain"
    },
    {
        "text": "In practice, we find that our SIMD GA LL OPIN G is always faster",
        "box": [
            226,
            515,
            500,
            525
        ],
        "class": "fstline",
        "page": 14,
        "is_meta": false,
        "parent_id": 579,
        "relation": "contain"
    },
    {
        "text": "than a non-SIMD galloping implementation. Nevertheless, to fully exploit the speed of SIMD",
        "box": [
            93,
            528,
            500,
            538
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 580,
        "relation": "connect"
    },
    {
        "text": "instructions, we find it desirable to still use V1 and V3 when they are faster. Thus, when processing",
        "box": [
            93,
            540,
            500,
            550
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 581,
        "relation": "connect"
    },
    {
        "text": "32-bit integers, we use a combination of V1, V 3, and SIMD galloping where a choice of the",
        "box": [
            93,
            552,
            500,
            562
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 582,
        "relation": "connect"
    },
    {
        "text": "intersection algorithm is defined by the following heuristic:",
        "box": [
            93,
            564,
            336,
            574
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 583,
        "relation": "connect"
    },
    {
        "text": "\u2022 When length(r) \u2264 length(f ) < 50 \u00d7 length(r), we use the V 1 algorithm with 8-integer",
        "box": [
            109,
            587,
            500,
            597
        ],
        "class": "fstline",
        "page": 14,
        "is_meta": false,
        "parent_id": 580,
        "relation": "equality"
    },
    {
        "text": "vectors (T = 8, see Algorithm 2).",
        "box": [
            118,
            599,
            256,
            609
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 585,
        "relation": "connect"
    },
    {
        "text": "\u2022 When 50 \u00d7 length(r) \u2264 length(f ) < 1000 \u00d7 length(r), we use the V3 algorithm with 32-",
        "box": [
            109,
            620,
            500,
            631
        ],
        "class": "fstline",
        "page": 14,
        "is_meta": false,
        "parent_id": 585,
        "relation": "equality"
    },
    {
        "text": "integer vectors (T = 32, see Algorithm 3)",
        "box": [
            118,
            632,
            289,
            643
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 587,
        "relation": "connect"
    },
    {
        "text": "\u2022 When 1000 \u00d7 length(r ) \u2264 length(f ), we use the S I MD GA LL OPIN G algorithm with 32-",
        "box": [
            109,
            654,
            500,
            664
        ],
        "class": "fstline",
        "page": 14,
        "is_meta": false,
        "parent_id": 587,
        "relation": "equality"
    },
    {
        "text": "integer vectors (T = 32, see Algorithm 4).",
        "box": [
            118,
            666,
            292,
            676
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 589,
        "relation": "connect"
    },
    {
        "text": "Though we are most interested in 32-bit integers, V1, V 3 and SI M D G AL LO P ING can also be used",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "fstline",
        "page": 14,
        "is_meta": false,
        "parent_id": 589,
        "relation": "equality"
    },
    {
        "text": "with arrays of 8-bit, 16-bit and 64-bit integers. Different heuristics would be needed in such cases.",
        "box": [
            93,
            701,
            496,
            711
        ],
        "class": "para",
        "page": 14,
        "is_meta": false,
        "parent_id": 591,
        "relation": "connect"
    },
    {
        "text": "16",
        "box": [
            93,
            38,
            103,
            49
        ],
        "class": "header",
        "page": 15,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 15,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "6.2.2. Possible refinements",
        "box": [
            93,
            68,
            208,
            79
        ],
        "class": "sec3",
        "page": 15,
        "is_meta": false,
        "parent_id": 579,
        "relation": "equality"
    },
    {
        "text": "Our SIMD Intersection algorithms assume that the longer array has",
        "box": [
            208,
            67,
            501,
            78
        ],
        "class": "fstline",
        "page": 15,
        "is_meta": false,
        "parent_id": 595,
        "relation": "contain"
    },
    {
        "text": "length divisible by either T or 4T. In practice, when this is not the case, we complete the",
        "box": [
            93,
            80,
            500,
            91
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 596,
        "relation": "connect"
    },
    {
        "text": "computation of the intersection with the S C AL AR algorithm. We expect that the contribution of",
        "box": [
            93,
            92,
            500,
            102
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 597,
        "relation": "connect"
    },
    {
        "text": "this step to the total running time is small. As a possibly faster alternative, we could pad the longer",
        "box": [
            93,
            104,
            500,
            114
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 598,
        "relation": "connect"
    },
    {
        "text": "array to a desired length using a special integer value that is guaranteed not to be in the shorter array.",
        "box": [
            93,
            116,
            500,
            126
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 599,
        "relation": "connect"
    },
    {
        "text": "We could also fallback on other SIMD algorithms to complete the computation of the intersection.",
        "box": [
            93,
            128,
            497,
            138
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 600,
        "relation": "connect"
    },
    {
        "text": "We could introduce other refinements. For example, our implementation of SIM D G AL LO P I NG",
        "box": [
            103,
            140,
            499,
            150
        ],
        "class": "fstline",
        "page": 15,
        "is_meta": false,
        "parent_id": 596,
        "relation": "equality"
    },
    {
        "text": "relies on a scalar binary search like the conventional galloping. However, recent Intel processors",
        "box": [
            93,
            152,
            500,
            162
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 602,
        "relation": "connect"
    },
    {
        "text": "have introduced gather instructions (vpgatherdd) that can retrieve at once several integers from",
        "box": [
            93,
            163,
            500,
            174
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 603,
        "relation": "connect"
    },
    {
        "text": "various locations [34]. Such instructions could accelerate binary search. We do not consider such",
        "box": [
            93,
            176,
            500,
            186
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 604,
        "relation": "connect"
    },
    {
        "text": "possibilities further.",
        "box": [
            93,
            188,
            175,
            198
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 605,
        "relation": "connect"
    },
    {
        "text": "Algorithm 3 The V 3 intersection algorithmRequire: SIMD architecture with T-integer vectors1: input: two sorted non-empty arrays of integers r, f2: assume: length(f ) is divisible by 4T3: x initially empty dynamic array (our answer)4: j \u2190 15: for i \u2208 {1, 2, . . . , length(r)} do6: R \u2190 (ri, ri , . . . , ri)7: while fj\u22121+4T < ri do8: j \u2190 j + 4T9: if j > length(f ) then10: return x11: if fj \u22121+2T \u2265 ri then12: if fj \u22121+T \u2265 ri then13: F \u2190 (fj , fj +1, . . . , fj\u22121+T)14: else15: F \u2190 (fj+T, fj+2+T , . . . , fj \u22121+2T )16: else17: if fj \u22121+3T \u2265 ri then18: F \u2190 (fj+2T, fj+2+2T , . . . , fj\u22121+3T )19: else20: F \u2190 (fj+3T, fj+2+3T , . . . , fj\u22121+4T )21: if Ri = Fi for some i \u2208 {1, 2, . . . , T} then22: append ri to x23: return x",
        "box": [
            91,
            210,
            501,
            519
        ],
        "class": "tab",
        "page": 15,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "7. EXPERIMENTAL RESULTS",
        "box": [
            228,
            554,
            365,
            564
        ],
        "class": "sec1",
        "page": 15,
        "is_meta": false,
        "parent_id": 434,
        "relation": "equality"
    },
    {
        "text": "We assess experimentally the unpacking speed with integrated differential coding (\u00a7 7.4), the",
        "box": [
            93,
            578,
            500,
            588
        ],
        "class": "fstline",
        "page": 15,
        "is_meta": false,
        "parent_id": 608,
        "relation": "contain"
    },
    {
        "text": "decompression speed of the corresponding schemes (\u00a7 7.5), the benefits of our SIMD-based",
        "box": [
            93,
            590,
            500,
            600
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 609,
        "relation": "connect"
    },
    {
        "text": "intersection schemes (\u00a7 7.6), and, SIMD-accelerated bitmap-list hybrids (\u00a7 7.7) with realistic query",
        "box": [
            93,
            602,
            500,
            612
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 610,
        "relation": "connect"
    },
    {
        "text": "logs and inverted indexes.",
        "box": [
            93,
            614,
            199,
            624
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 611,
        "relation": "connect"
    },
    {
        "text": "7.1. Software",
        "box": [
            93,
            638,
            150,
            649
        ],
        "class": "sec2",
        "page": 15,
        "is_meta": false,
        "parent_id": 608,
        "relation": "contain"
    },
    {
        "text": "All our software is freely available online\u2021 under the Apache Software License 2.0. The code",
        "box": [
            93,
            655,
            500,
            667
        ],
        "class": "fstline",
        "page": 15,
        "is_meta": false,
        "parent_id": 613,
        "relation": "contain"
    },
    {
        "text": "is written in C++ using the C++11 standard. Our code builds using several compilers such as",
        "box": [
            93,
            668,
            500,
            679
        ],
        "class": "para",
        "page": 15,
        "is_meta": false,
        "parent_id": 614,
        "relation": "connect"
    },
    {
        "text": "\u2021 https://github.com/lemire/SIMDCompressionAndIntersection.",
        "box": [
            93,
            701,
            384,
            711
        ],
        "class": "fnote",
        "page": 15,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 16,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "17",
        "box": [
            489,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 16,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Algorithm 4 The S I MD G AL LO P IN G algorithmRequire: SIMD architecture with T-integer vectors1: input: two non-empty sorted arrays of integers r, f2: assume: length(f ) is divisible by T3: x initially empty dynamic array (our answer)4: j \u2190 15: for i \u2208 {1, 2, . . . , length(r)} do6: R \u2190 (ri, ri , . . . , ri)7: find by sequential search the smallest \u03b4 such that fj +\u03b4\u22121+T \u2265 ri for \u03b4 =0, 1T, 2T, 4T, . . . , length(f ) \u2212 1 + T, if none return x8: find by binary search the smallest \u03b4min in [\u230a\u03b4 /2\u230b, \u03b4] divisible by T such that fj+\u03b4min \u22121+T \u2265 ri9: j \u2190 j + \u03b4min10: F \u2190 (fj , fj +1, . . . , fj\u22121+T)11: if Ri = Fi for some i \u2208 {1, 2, . . . , T} then12: append ri to x13: return x",
        "box": [
            91,
            64,
            499,
            275
        ],
        "class": "tab",
        "page": 16,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "clang++ 3.2 and Intel icpc 13. However, we use GNU GCC 4.7 on a Linux PC for our tests. All",
        "box": [
            93,
            298,
            500,
            309
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 615,
        "relation": "connect"
    },
    {
        "text": "code was compiled using the -O3 flag. We implemented scalar schemes ( FAS TPF OR and VARIN T)",
        "box": [
            93,
            310,
            500,
            320
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 620,
        "relation": "connect"
    },
    {
        "text": "without using SIMD instructions and with the scalar equivalent of D1 differential coding.",
        "box": [
            93,
            322,
            461,
            332
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 621,
        "relation": "connect"
    },
    {
        "text": "7.2. Hardware",
        "box": [
            93,
            347,
            155,
            357
        ],
        "class": "sec2",
        "page": 16,
        "is_meta": false,
        "parent_id": 613,
        "relation": "equality"
    },
    {
        "text": "We ran all our experiments on an Intel Xeon CPU (E5-1620, Sandy Bridge) running at 3.60 . This",
        "box": [
            93,
            365,
            500,
            375
        ],
        "class": "fstline",
        "page": 16,
        "is_meta": false,
        "parent_id": 623,
        "relation": "contain"
    },
    {
        "text": "CPU also has 10 MB of L3 cache as well as 32 kB and 256 kB of L1 and L2 data cache per core.",
        "box": [
            93,
            377,
            500,
            387
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 624,
        "relation": "connect"
    },
    {
        "text": "We have 32 GB of RAM (DDR3-1600) running quad-channel. We estimate that we can read from",
        "box": [
            93,
            389,
            500,
            399
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 625,
        "relation": "connect"
    },
    {
        "text": "RAM at a speed of 4 billion 32-bit integers per second and from L3 cache at a speed of 8 billion",
        "box": [
            93,
            401,
            500,
            411
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 626,
        "relation": "connect"
    },
    {
        "text": "32-bit integers per second. All data is stored in RAM so that disk performance is irrelevant.",
        "box": [
            93,
            413,
            468,
            423
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 627,
        "relation": "connect"
    },
    {
        "text": "7.3. Real data",
        "box": [
            93,
            437,
            153,
            448
        ],
        "class": "sec2",
        "page": 16,
        "is_meta": false,
        "parent_id": 623,
        "relation": "equality"
    },
    {
        "text": "To fully assess our results, we need realistic data sets. For this purpose, we use posting lists",
        "box": [
            93,
            456,
            500,
            466
        ],
        "class": "fstline",
        "page": 16,
        "is_meta": false,
        "parent_id": 629,
        "relation": "contain"
    },
    {
        "text": "extracted from the TREC collections ClueWeb09 (Category B) and GOV2. Collections GOV2 and",
        "box": [
            93,
            468,
            500,
            478
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 630,
        "relation": "connect"
    },
    {
        "text": "ClueWeb09 (Category B) contain roughly 25 and 50 million HTML documents, respectively. These",
        "box": [
            93,
            479,
            500,
            490
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 631,
        "relation": "connect"
    },
    {
        "text": "documents were crawled from the web. In the case of GOV2 almost all pages were collected from",
        "box": [
            93,
            491,
            500,
            502
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 632,
        "relation": "connect"
    },
    {
        "text": "websites in either the .gov or .us domains, but the ClueWeb09 crawl was not limited to any",
        "box": [
            93,
            503,
            500,
            514
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 633,
        "relation": "connect"
    },
    {
        "text": "specific domain.",
        "box": [
            93,
            515,
            160,
            526
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 634,
        "relation": "connect"
    },
    {
        "text": "ClueWeb09 is a partially sorted collection: on average it has runs of 3.7 thousand documents",
        "box": [
            103,
            527,
            500,
            538
        ],
        "class": "fstline",
        "page": 16,
        "is_meta": false,
        "parent_id": 630,
        "relation": "equality"
    },
    {
        "text": "sorted by URLs. In GOV2, the average length of the sorted run is almost one. Thus, we use two",
        "box": [
            93,
            539,
            500,
            550
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 636,
        "relation": "connect"
    },
    {
        "text": "variants of GOV2: the original and a sorted one, where documents are sorted by their URLs. We",
        "box": [
            93,
            551,
            500,
            561
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 637,
        "relation": "connect"
    },
    {
        "text": "did not consider other sorting strategies such as by number of terms in the document (terms-in-",
        "box": [
            93,
            563,
            500,
            573
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 638,
        "relation": "connect"
    },
    {
        "text": "document) or by document size [15, 35].",
        "box": [
            93,
            575,
            260,
            585
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 639,
        "relation": "connect"
    },
    {
        "text": "We first indexed collections using Lucene (version 4.6.0): the words were stopped using the",
        "box": [
            103,
            587,
            500,
            597
        ],
        "class": "fstline",
        "page": 16,
        "is_meta": false,
        "parent_id": 636,
        "relation": "equality"
    },
    {
        "text": "default Lucene settings, but not stemmed. Then, we extracted postings corresponding to one",
        "box": [
            93,
            599,
            500,
            609
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 641,
        "relation": "connect"
    },
    {
        "text": "million most frequent terms. In both GOV2 and ClueWeb09, the excluded terms represent 4 %",
        "box": [
            93,
            611,
            500,
            621
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 642,
        "relation": "connect"
    },
    {
        "text": "of the postings. Morever, the excluded posting lists had averages of 3.2 postings for GOV2 and",
        "box": [
            93,
            623,
            500,
            633
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 643,
        "relation": "connect"
    },
    {
        "text": "4.5 postings for ClueWeb09. The extracting software as well as the processed data is freely available",
        "box": [
            93,
            635,
            500,
            645
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 644,
        "relation": "connect"
    },
    {
        "text": "online.\u00a7 Uncompressed, extracted posting lists from GOV2 and ClueWeb09 use 23 GB and 59 GB,",
        "box": [
            93,
            646,
            500,
            657
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 645,
        "relation": "connect"
    },
    {
        "text": "respectively. They include only document identifiers.",
        "box": [
            93,
            659,
            310,
            669
        ],
        "class": "para",
        "page": 16,
        "is_meta": false,
        "parent_id": 646,
        "relation": "connect"
    },
    {
        "text": "\u00a7 https://github.com/searchivarius/IndexTextCollect and http://lemire.me/data/",
        "box": [
            93,
            692,
            500,
            702
        ],
        "class": "fnote",
        "page": 16,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "integercompression2014.html.",
        "box": [
            93,
            702,
            232,
            711
        ],
        "class": "opara",
        "page": 16,
        "is_meta": true,
        "parent_id": 648,
        "relation": "connect"
    },
    {
        "text": "18",
        "box": [
            93,
            38,
            103,
            49
        ],
        "class": "header",
        "page": 17,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 17,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Our corpora represent realistic sets of documents obtained by splitting a large collection so that",
        "box": [
            103,
            68,
            500,
            79
        ],
        "class": "fstline",
        "page": 17,
        "is_meta": false,
        "parent_id": 641,
        "relation": "equality"
    },
    {
        "text": "each part fits into the memory of a single server. In comparison, other researchers use collections of",
        "box": [
            93,
            80,
            500,
            91
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 652,
        "relation": "connect"
    },
    {
        "text": "similar or smaller sizes. Culpepper and Moffat [5], Ao et al. [17], Barbay et al. [14], Ding et al. [16]",
        "box": [
            93,
            92,
            500,
            102
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 653,
        "relation": "connect"
    },
    {
        "text": "and Vigna [19] used TREC GOV2 (25M documents), Ding and K \u00a8onig [9] indexed Wikipedia (14M",
        "box": [
            93,
            104,
            500,
            114
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 654,
        "relation": "connect"
    },
    {
        "text": "documents) while Transier and Sanders [10] used WT2g (250k documents).",
        "box": [
            93,
            116,
            404,
            126
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 655,
        "relation": "connect"
    },
    {
        "text": "7.3.1. Query logs",
        "box": [
            93,
            140,
            169,
            153
        ],
        "class": "sec3",
        "page": 17,
        "is_meta": false,
        "parent_id": 629,
        "relation": "contain"
    },
    {
        "text": "In addition, we used the TREC million-query track (1MQ) logs (60 thousand",
        "box": [
            171,
            139,
            500,
            151
        ],
        "class": "fstline",
        "page": 17,
        "is_meta": false,
        "parent_id": 657,
        "relation": "contain"
    },
    {
        "text": "queries from years 2007\u20132009). We randomly picked 20 thousand queries containing at least",
        "box": [
            93,
            153,
            500,
            163
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 658,
        "relation": "connect"
    },
    {
        "text": "two indexed terms. These queries were converted into sequences of posting identifiers for GOV2",
        "box": [
            93,
            165,
            500,
            175
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 659,
        "relation": "connect"
    },
    {
        "text": "and ClueWeb09. Recall that postings beyond one million most frequent terms were eliminated.",
        "box": [
            93,
            176,
            500,
            187
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 660,
        "relation": "connect"
    },
    {
        "text": "Therefore, we had to exclude 4.6 % of queries in the case of ClueWeb09 and 8.4 % of queries in",
        "box": [
            93,
            188,
            500,
            199
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 661,
        "relation": "connect"
    },
    {
        "text": "the case of GOV2 (which could not be converted to posting identifiers). We believe that excluding",
        "box": [
            93,
            200,
            500,
            211
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 662,
        "relation": "connect"
    },
    {
        "text": "a small fraction of the queries slightly biased up processing times, but the overall effect was not",
        "box": [
            93,
            212,
            500,
            223
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 663,
        "relation": "connect"
    },
    {
        "text": "substantial.",
        "box": [
            93,
            224,
            140,
            235
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 664,
        "relation": "connect"
    },
    {
        "text": "Table IV gives intersection statistics for the GOV2 and Clueweb09 collections. We give the",
        "box": [
            103,
            236,
            500,
            247
        ],
        "class": "fstline",
        "page": 17,
        "is_meta": false,
        "parent_id": 658,
        "relation": "equality"
    },
    {
        "text": "percentage of all queries having a given number of terms, the average size of the intersection, along",
        "box": [
            93,
            248,
            500,
            258
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 666,
        "relation": "connect"
    },
    {
        "text": "with the average size of the smallest posting list (term 1), the average size of the second smallest",
        "box": [
            93,
            260,
            500,
            270
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 667,
        "relation": "connect"
    },
    {
        "text": "(term 2) and so on.",
        "box": [
            93,
            272,
            171,
            282
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 668,
        "relation": "connect"
    },
    {
        "text": "To insure that all our indexes fit in RAM, we index only the terms used by the given query log.",
        "box": [
            103,
            284,
            500,
            294
        ],
        "class": "fstline",
        "page": 17,
        "is_meta": false,
        "parent_id": 666,
        "relation": "equality"
    },
    {
        "text": "When reporting compression results (in bits/int), we only consider this in-memory index.",
        "box": [
            93,
            296,
            459,
            306
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 670,
        "relation": "connect"
    },
    {
        "text": "Table IV. Statistics about the TREC Million-Query log on two corpora. We give the percentage of all queries",
        "box": [
            93,
            318,
            500,
            328
        ],
        "class": "tabcap",
        "page": 17,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "having a given number of terms, the average size of the intersection along with the average size of the",
        "box": [
            93,
            328,
            500,
            338
        ],
        "class": "opara",
        "page": 17,
        "is_meta": false,
        "parent_id": 672,
        "relation": "connect"
    },
    {
        "text": "smallest posting list (term 1), the average size of the second smallest (term 2) and so on. All sizes are in",
        "box": [
            93,
            338,
            500,
            348
        ],
        "class": "opara",
        "page": 17,
        "is_meta": false,
        "parent_id": 673,
        "relation": "connect"
    },
    {
        "text": "thousands. There are 50M documents in total for Clueweb09 and half as many for Gov2.",
        "box": [
            127,
            348,
            463,
            358
        ],
        "class": "opara",
        "page": 17,
        "is_meta": false,
        "parent_id": 674,
        "relation": "connect"
    },
    {
        "text": "(a) Clueweb09 (matching documents in thousands)# % inter. term 1, term 2, . . .2 19.8 93 380, 26003 32.5 29 400, 1500, 51004 26.3 17 480, 1400, 3200, 81005 13.2 12 420, 1200, 2600, 4800, 10 0006 4.9 4 350, 1000, 2100, 3700, 6500, 13 0007 1.7 5 390, 1100, 2100, 3400, 5200, 7300, 13 000(b) Gov2 (matching documents in thousands)# % inter. term 1, term 2 , . . .2 19.6 49 160, 11003 32.3 22 180, 710, 24004 26.4 11 210, 620, 1500, 37005 13.4 7 170, 520, 1100, 2200, 44006 5.0 3 140, 420, 850, 1500, 2600, 51007 1.8 9 190, 440, 790, 1300, 2200, 3200, 5400",
        "box": [
            157,
            365,
            430,
            574
        ],
        "class": "tab",
        "page": 17,
        "is_meta": false,
        "parent_id": 672,
        "relation": "contain"
    },
    {
        "text": "7.4. Bit unpacking",
        "box": [
            93,
            611,
            171,
            621
        ],
        "class": "sec2",
        "page": 17,
        "is_meta": false,
        "parent_id": 629,
        "relation": "equality"
    },
    {
        "text": "Bit unpacking (see \u00a7 4.2) is the fundamental operation we use as building blocks for our compression",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "fstline",
        "page": 17,
        "is_meta": false,
        "parent_id": 677,
        "relation": "contain"
    },
    {
        "text": "schemes (i.e., the families S 4-B P 128, FA S TP F O R, S4- FA ST P F O R). In our experiments,",
        "box": [
            93,
            641,
            500,
            651
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 678,
        "relation": "connect"
    },
    {
        "text": "unpacking always includes differential coding, as an integrated operation or a separate step (see",
        "box": [
            93,
            653,
            500,
            663
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 679,
        "relation": "connect"
    },
    {
        "text": "\u00a7 5).",
        "box": [
            93,
            665,
            112,
            675
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 680,
        "relation": "connect"
    },
    {
        "text": "To test the speed of our various bit unpacking routines, we generated random arrays of 4096 32-",
        "box": [
            103,
            677,
            500,
            687
        ],
        "class": "fstline",
        "page": 17,
        "is_meta": false,
        "parent_id": 678,
        "relation": "equality"
    },
    {
        "text": "bit integers for each bit width b = 1, 2, . . . , 31. We generated gaps smaller than 2b using the C",
        "box": [
            93,
            688,
            500,
            699
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 682,
        "relation": "connect"
    },
    {
        "text": "rand function as a pseudo-random number generator. Because SIMD unpacking routines operate",
        "box": [
            93,
            700,
            500,
            711
        ],
        "class": "para",
        "page": 17,
        "is_meta": false,
        "parent_id": 683,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "fstline",
        "page": 18,
        "is_meta": false,
        "parent_id": 682,
        "relation": "equality"
    },
    {
        "text": "19",
        "box": [
            489,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 18,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "0102030405060 5 10 15 20 25 30Cyclestounpack128ints Bit width",
        "box": [
            145,
            72,
            432,
            236
        ],
        "class": "fig",
        "page": 18,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Figure 5. Estimated reciprocal throughput of the SIMD unpacking procedures according to IACA (for",
        "box": [
            93,
            247,
            500,
            256
        ],
        "class": "figcap",
        "page": 18,
        "is_meta": false,
        "parent_id": 687,
        "relation": "contain"
    },
    {
        "text": "128 32-bit integers and without differential coding).",
        "box": [
            198,
            257,
            395,
            266
        ],
        "class": "opara",
        "page": 18,
        "is_meta": false,
        "parent_id": 688,
        "relation": "connect"
    },
    {
        "text": "on blocks of 128 integers (see Algorithm 1), a total of 4096/128 = 32 calls to the same unpacking",
        "box": [
            93,
            330,
            500,
            341
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 685,
        "relation": "connect"
    },
    {
        "text": "routine is required to unpack an entire array. For each bit width, we ran 214 sequences of packing",
        "box": [
            93,
            341,
            500,
            353
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 690,
        "relation": "connect"
    },
    {
        "text": "and unpacking and report only the average.",
        "box": [
            93,
            354,
            270,
            365
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 691,
        "relation": "connect"
    },
    {
        "text": "Generally, unpacking is fastest for low bit widths and for bit widths that are powers of two.",
        "box": [
            103,
            366,
            500,
            376
        ],
        "class": "fstline",
        "page": 18,
        "is_meta": false,
        "parent_id": 685,
        "relation": "equality"
    },
    {
        "text": "We used the Intel Architecture Code Analyzer (IACA) on our 32 SIMD unpacking routines\u2014",
        "box": [
            93,
            378,
            500,
            388
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 693,
        "relation": "connect"
    },
    {
        "text": "omitting differential coding for simplicity. IACA provides an optimistic estimation of the reciprocal",
        "box": [
            93,
            390,
            500,
            400
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 694,
        "relation": "connect"
    },
    {
        "text": "throughput of these procedures: a value of 32 cycles means that if we repeatedly called the same",
        "box": [
            93,
            402,
            500,
            412
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 695,
        "relation": "connect"
    },
    {
        "text": "routine, one full routine might complete every 32 cycles. Thus, in our case, we get an optimistic",
        "box": [
            93,
            414,
            500,
            424
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 696,
        "relation": "connect"
    },
    {
        "text": "estimate of the number of cycles it takes to unpack 128 integers. Fig. 5 provides this reciprocal",
        "box": [
            93,
            426,
            500,
            436
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 697,
        "relation": "connect"
    },
    {
        "text": "throughput for all bit widths on our processor microarchitecture (Sandy Bridge). It takes between",
        "box": [
            93,
            438,
            500,
            448
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 698,
        "relation": "connect"
    },
    {
        "text": "32 to 61 cycles to execute each 128-integer unpacking procedure, and the estimated throughput",
        "box": [
            93,
            450,
            500,
            460
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 699,
        "relation": "connect"
    },
    {
        "text": "depends on the bit width. IACA reports that execution port 4 is a bottleneck for bit widths 1, 2, 3, 4,",
        "box": [
            93,
            462,
            500,
            472
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 700,
        "relation": "connect"
    },
    {
        "text": "8, 16, 32: it indicates that we are limited by register stores in these cases. Indeed, 32 128-bit store",
        "box": [
            93,
            474,
            500,
            484
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 701,
        "relation": "connect"
    },
    {
        "text": "operations are required to write 128 32-bit integers and we can only issue one store instruction per",
        "box": [
            93,
            486,
            500,
            496
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 702,
        "relation": "connect"
    },
    {
        "text": "cycle: we therefore need 32 cycles. Otherwise, execution port 0 is a bottleneck. This port is used by",
        "box": [
            93,
            498,
            500,
            508
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 703,
        "relation": "connect"
    },
    {
        "text": "shift instructions on Sandy Bridge: these instructions are used more often when bit widths are large,",
        "box": [
            93,
            509,
            500,
            520
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 704,
        "relation": "connect"
    },
    {
        "text": "except if the bit width is a power of two.",
        "box": [
            93,
            522,
            259,
            532
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 705,
        "relation": "connect"
    },
    {
        "text": "In Fig. 6a, we plot the speed ratios of the integrated bit unpacking (i.e., Algorithm 1 for SIMD",
        "box": [
            103,
            534,
            500,
            544
        ],
        "class": "fstline",
        "page": 18,
        "is_meta": false,
        "parent_id": 693,
        "relation": "equality"
    },
    {
        "text": "routines), vs. the regular one where differential coding is applied separately on small blocks of 32-",
        "box": [
            93,
            546,
            500,
            556
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 707,
        "relation": "connect"
    },
    {
        "text": "bit integers. To differentiate the integrated and regular differential coding we use an i prefix (iD4",
        "box": [
            93,
            557,
            499,
            568
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 708,
        "relation": "connect"
    },
    {
        "text": "vs. D 4). For D 4, integration improves the speed by anywhere from over 30 % to 90 %. For D1 , the",
        "box": [
            93,
            569,
            500,
            580
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 709,
        "relation": "connect"
    },
    {
        "text": "results are less impressive as the gains range from 20 % to 40 %. For D2 and DM, the result lies",
        "box": [
            93,
            581,
            500,
            592
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 710,
        "relation": "connect"
    },
    {
        "text": "in-between. Moreover, the gains due to the integration are most important when the unpacking is",
        "box": [
            93,
            593,
            500,
            604
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 711,
        "relation": "connect"
    },
    {
        "text": "fastest: for small bit widths or bit widths that are a power of two such as 8 and 16. This phenomenon",
        "box": [
            93,
            605,
            500,
            616
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 712,
        "relation": "connect"
    },
    {
        "text": "is consistent with our analysis (see \u00a7 5): the benefits of integration are mostly due to the reduction",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 713,
        "relation": "connect"
    },
    {
        "text": "by half of the number of registers stored to memory, and these stores are more of a bottleneck for",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 714,
        "relation": "connect"
    },
    {
        "text": "these particular bit widths.",
        "box": [
            93,
            641,
            202,
            651
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 715,
        "relation": "connect"
    },
    {
        "text": "In Fig. 6b, we compare all of the integrated bit unpacking procedures (iD4, iD M, i D 2, iD1 ).",
        "box": [
            103,
            653,
            500,
            663
        ],
        "class": "fstline",
        "page": 18,
        "is_meta": false,
        "parent_id": 707,
        "relation": "equality"
    },
    {
        "text": "As our analysis predicted (see Table III), D 4 is the fastest followed by DM , D 2 and D1 . For",
        "box": [
            93,
            665,
            500,
            675
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 717,
        "relation": "connect"
    },
    {
        "text": "comparison, we also include the scalar bit unpacking speed. The integrated bit unpacking (iscalar",
        "box": [
            93,
            677,
            500,
            687
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 718,
        "relation": "connect"
    },
    {
        "text": "curve) is sometimes twice as fast as regular bit unpacking (scalar curve). Even so, the fastest scalar",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 719,
        "relation": "connect"
    },
    {
        "text": "unpacking routine has half the speed as our slowest SIMD unpacking routine (iD 1).",
        "box": [
            93,
            701,
            437,
            711
        ],
        "class": "para",
        "page": 18,
        "is_meta": false,
        "parent_id": 720,
        "relation": "connect"
    },
    {
        "text": "20",
        "box": [
            93,
            38,
            103,
            49
        ],
        "class": "header",
        "page": 19,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 19,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "1.21.31.41.51.61.71.81.9 5 10 15 20 25 30Relativespeed(D4=1) Bit width iD4/D4iD1/D1(a) One-pass (integrated) vs. two-pass (block-level) prefix sum0123456789 5 10 15 20 25 30Speed(Bints/s) Bit widthiD4iDMiD2 iD1iscalarscalar(b) Several differential bit unpacking speeds",
        "box": [
            150,
            64,
            438,
            445
        ],
        "class": "fig",
        "page": 19,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Figure 6. Unpacking speed for all bit widths (b = 1, . . . , 31). See Algorithm 1. Speed is reported in billions",
        "box": [
            93,
            454,
            500,
            464
        ],
        "class": "figcap",
        "page": 19,
        "is_meta": false,
        "parent_id": 724,
        "relation": "contain"
    },
    {
        "text": "of 32-bit integers per second. We use arrays of 4096 integers for these tests.",
        "box": [
            152,
            464,
            438,
            474
        ],
        "class": "opara",
        "page": 19,
        "is_meta": false,
        "parent_id": 725,
        "relation": "connect"
    },
    {
        "text": "7.5. Decompression speed",
        "box": [
            93,
            499,
            203,
            509
        ],
        "class": "sec2",
        "page": 19,
        "is_meta": false,
        "parent_id": 677,
        "relation": "equality"
    },
    {
        "text": "We consider several fast compression schemes: VA R IN T (see \u00a7 4.1), S4-BP 12 8 (see \u00a7 4.3),",
        "box": [
            93,
            517,
            500,
            528
        ],
        "class": "fstline",
        "page": 19,
        "is_meta": false,
        "parent_id": 727,
        "relation": "contain"
    },
    {
        "text": "FAST PFOR and S 4-FAST P FOR (see \u00a7 4.4). To test the speed of our integer compression schemes,",
        "box": [
            93,
            529,
            500,
            540
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 728,
        "relation": "connect"
    },
    {
        "text": "we generated arrays using the ClusterData distribution from Anh and Moffat [25]. This distribution",
        "box": [
            93,
            541,
            500,
            552
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 729,
        "relation": "connect"
    },
    {
        "text": "primarily leaves small gaps between successive integers, punctuated by occasional larger gaps. We",
        "box": [
            93,
            553,
            500,
            563
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 730,
        "relation": "connect"
    },
    {
        "text": "generated arrays of 65536 32-bit integers in either [0, 219 ) or [0, 230). In each case, we give the",
        "box": [
            93,
            564,
            500,
            575
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 731,
        "relation": "connect"
    },
    {
        "text": "decompression speed of our schemes, the entropy of the deltas as well as the speed (in billions",
        "box": [
            93,
            577,
            500,
            587
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 732,
        "relation": "connect"
    },
    {
        "text": "of 32-bit integers per second) of a simple copy (implemented as a call to memcpy) in Table V.",
        "box": [
            93,
            588,
            500,
            599
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 733,
        "relation": "connect"
    },
    {
        "text": "All compression schemes use differential coding. We append a suffix ( -D4, - D M, - D 2, and - D 1)",
        "box": [
            93,
            601,
            500,
            611
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 734,
        "relation": "connect"
    },
    {
        "text": "to indicate the type of differential coding used. We append the - N I suffix (for non-integrated ) to",
        "box": [
            93,
            613,
            500,
            623
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 735,
        "relation": "connect"
    },
    {
        "text": "S 4-BP 12 8 - * schemes where the prefix sum requires a second pass. We get our best speeds with",
        "box": [
            93,
            625,
            500,
            635
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 736,
        "relation": "connect"
    },
    {
        "text": "S 4-BP 12 8 - D4 and S 4-B P 128 - D M.\u00b6 Given our 3.60 clock speed, they decompress 32-bit integers",
        "box": [
            93,
            636,
            500,
            647
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 737,
        "relation": "connect"
    },
    {
        "text": "using between 0.7 and 0.8 CPU cycles per integer. In contrast, the best results reported by Lemire",
        "box": [
            93,
            649,
            500,
            659
        ],
        "class": "para",
        "page": 19,
        "is_meta": false,
        "parent_id": 738,
        "relation": "connect"
    },
    {
        "text": "\u00b6Though we report a greater speed in one instance for S4 -BP12 8- DM (5.5) than for S 4- B P 128 -D4 (5.4), the 3-digit",
        "box": [
            93,
            692,
            500,
            702
        ],
        "class": "fnote",
        "page": 19,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "values are close: 5.45 and 5.44.",
        "box": [
            93,
            702,
            199,
            711
        ],
        "class": "opara",
        "page": 19,
        "is_meta": true,
        "parent_id": 740,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 20,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "21",
        "box": [
            489,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 20,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Table V. Results on ClusterData for dense (216 integers in [0, 219)) and sparse (216 integers in [0, 230)).",
        "box": [
            93,
            65,
            500,
            77
        ],
        "class": "tabcap",
        "page": 20,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "We report decompression speed in billions of 32-bit integers per second (Bint32/s). Shannon entropy of the",
        "box": [
            93,
            77,
            500,
            87
        ],
        "class": "opara",
        "page": 20,
        "is_meta": false,
        "parent_id": 744,
        "relation": "connect"
    },
    {
        "text": "deltas is given. Our Intel CPU runs at 3.6 . The -NI suffix (for non-integrated ) indicates that the prefix sum",
        "box": [
            93,
            87,
            500,
            97
        ],
        "class": "opara",
        "page": 20,
        "is_meta": false,
        "parent_id": 745,
        "relation": "connect"
    },
    {
        "text": "requires a second pass over 128-integer blocks. The standard deviation of our timings is less than 5 %.",
        "box": [
            102,
            97,
            488,
            107
        ],
        "class": "opara",
        "page": 20,
        "is_meta": false,
        "parent_id": 746,
        "relation": "connect"
    },
    {
        "text": "TABLE",
        "box": [
            172,
            118,
            421,
            337
        ],
        "class": "tab",
        "page": 20,
        "is_meta": false,
        "parent_id": 744,
        "relation": "contain"
    },
    {
        "text": "and Boytsov [3] was 1.2 CPU cycles per 32-bit integer, using similar synthetic data with a CPU of",
        "box": [
            93,
            360,
            500,
            371
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 739,
        "relation": "connect"
    },
    {
        "text": "the same family (Sandy Bridge).",
        "box": [
            93,
            372,
            226,
            383
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 749,
        "relation": "connect"
    },
    {
        "text": "S4-BP 12 8 -D1- N I is 38 % faster than S4-FastPFOR but S4-FastPFOR compensates with a",
        "box": [
            103,
            384,
            500,
            394
        ],
        "class": "fstline",
        "page": 20,
        "is_meta": false,
        "parent_id": 728,
        "relation": "equality"
    },
    {
        "text": "superior compression ratio (5 %\u201315 % better). However, with integration, S 4 - B P1 28- D 1 increases",
        "box": [
            93,
            396,
            500,
            406
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 751,
        "relation": "connect"
    },
    {
        "text": "the speed gap to 50 %\u201375 %.",
        "box": [
            93,
            408,
            210,
            418
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 752,
        "relation": "connect"
    },
    {
        "text": "7.6. Intersections",
        "box": [
            93,
            432,
            166,
            442
        ],
        "class": "sec2",
        "page": 20,
        "is_meta": false,
        "parent_id": 727,
        "relation": "equality"
    },
    {
        "text": "We present several intersections algorithms between (uncompressed) lists of 32-bit integers in \u00a7 6.",
        "box": [
            93,
            450,
            500,
            460
        ],
        "class": "fstline",
        "page": 20,
        "is_meta": false,
        "parent_id": 754,
        "relation": "contain"
    },
    {
        "text": "To test these intersections, we again generate lists using the ClusterData distribution [25]: all lists",
        "box": [
            93,
            462,
            500,
            472
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 755,
        "relation": "connect"
    },
    {
        "text": "contain integers in [0, 226 ). Lists are generated in pairs. First, we set the target cardinality n of",
        "box": [
            93,
            473,
            500,
            484
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 756,
        "relation": "connect"
    },
    {
        "text": "the largest lists to 222 . Then we vary the target cardinality m of the smallest list from n down to",
        "box": [
            93,
            485,
            500,
            496
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 757,
        "relation": "connect"
    },
    {
        "text": "n/10000. To ensure that intersections are not trivial, we first generate an \u201cintersection\u201d list of size",
        "box": [
            93,
            498,
            500,
            508
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 758,
        "relation": "connect"
    },
    {
        "text": "m/3 (rounded to the nearest integer). The smallest list is built from the union of the intersection",
        "box": [
            93,
            510,
            500,
            520
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 759,
        "relation": "connect"
    },
    {
        "text": "list with another list made of 2m/3 integers. Thus, the maximum length of this union is m. The",
        "box": [
            93,
            522,
            500,
            532
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 760,
        "relation": "connect"
    },
    {
        "text": "longest list is made of the union of the intersection list with another list of cardinality n \u2212 m/3,",
        "box": [
            93,
            534,
            500,
            544
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 761,
        "relation": "connect"
    },
    {
        "text": "for a total cardinality of up to n. The net result is that we have two sets with cardinalities \u2248 m",
        "box": [
            93,
            546,
            500,
            556
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 762,
        "relation": "connect"
    },
    {
        "text": "and \u2248 n having an intersection at least as large as m/3. We compute the average of 5 intersections",
        "box": [
            93,
            557,
            500,
            568
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 763,
        "relation": "connect"
    },
    {
        "text": "(using 5 pairs of lists). This choice (m/3) is motivated by our experience with search engine queries",
        "box": [
            93,
            569,
            500,
            580
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 764,
        "relation": "connect"
    },
    {
        "text": "(e.g., see Table IV) where the intersection size is often about 30 % of the smaller of two sets for",
        "box": [
            93,
            581,
            500,
            592
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 765,
        "relation": "connect"
    },
    {
        "text": "2-term queries. We also present the figures for the case where the intersection is much smaller",
        "box": [
            93,
            593,
            500,
            604
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 766,
        "relation": "connect"
    },
    {
        "text": "(0.01m): the relative results are similar. The performance of the intersection procedures is sensitive",
        "box": [
            93,
            605,
            500,
            616
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 767,
        "relation": "connect"
    },
    {
        "text": "to the data distribution however. When we replaced ClusterData with a uniform distribution, the",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 768,
        "relation": "connect"
    },
    {
        "text": "intersection speed diminished by up to a factor of 2.5: value clustering improves branch predictions",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 769,
        "relation": "connect"
    },
    {
        "text": "and skipping [27].",
        "box": [
            93,
            641,
            168,
            651
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 770,
        "relation": "connect"
    },
    {
        "text": "We report all speeds relative to the basic S C AL AR intersection. All input lists are uncompressed.",
        "box": [
            103,
            653,
            500,
            663
        ],
        "class": "fstline",
        "page": 20,
        "is_meta": false,
        "parent_id": 755,
        "relation": "equality"
    },
    {
        "text": "In Fig. 7a, we compare the speed of our 3 SIMD intersection functions: V 1, V3 , and SIM D",
        "box": [
            93,
            665,
            499,
            675
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 772,
        "relation": "connect"
    },
    {
        "text": "GA LL OPIN G. We see that V1 is the fastest for ratios of up to 16:1, whereas S I M D G AL LO P I NG",
        "box": [
            93,
            677,
            499,
            687
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 773,
        "relation": "connect"
    },
    {
        "text": "is the fastest for ratios larger than 1024:1. In-between, V3 is sometimes best. This justifies our",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 774,
        "relation": "connect"
    },
    {
        "text": "heuristic which uses V 1 for ratios up to 50:1, V3 for ratios up to 1000:1, and SIMD G AL LO P I NG",
        "box": [
            93,
            701,
            499,
            711
        ],
        "class": "para",
        "page": 20,
        "is_meta": false,
        "parent_id": 775,
        "relation": "connect"
    },
    {
        "text": "22",
        "box": [
            93,
            38,
            103,
            49
        ],
        "class": "header",
        "page": 21,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 21,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Table VI. Time required to answer queries in ms/query along with the storage requirement in bits/int, using",
        "box": [
            93,
            66,
            500,
            75
        ],
        "class": "tabcap",
        "page": 21,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "the TREC Million-Query log sample from \u00a7 7.3.1. The standard deviation of our timings is less than 1 %.",
        "box": [
            97,
            76,
            495,
            85
        ],
        "class": "opara",
        "page": 21,
        "is_meta": false,
        "parent_id": 779,
        "relation": "connect"
    },
    {
        "text": "scheme bits/int time bits/int time bits/int timeG OV 2 G OV2 CL UE W EB0 9(sorted) (unsorted)SIMD SvS 32.0 0.5 32.0 0.7 32.0 1.5Galloping SvS 32.0 0.7 32.0 1.4 32.0 2.8S C A L A R SvS 32.0 2.8 32.0 3.3 32.0 6.6",
        "box": [
            174,
            93,
            421,
            172
        ],
        "class": "tab",
        "page": 21,
        "is_meta": false,
        "parent_id": 779,
        "relation": "contain"
    },
    {
        "text": "for larger ratios. In Fig. 7b, we compare the two non-SIMD intersections ( S C AL AR and galloping)",
        "box": [
            93,
            193,
            500,
            203
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 776,
        "relation": "connect"
    },
    {
        "text": "with our SIMD intersection procedure. We see that for a wide range of cases (up to a ratio of 64:1),",
        "box": [
            93,
            205,
            500,
            215
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 782,
        "relation": "connect"
    },
    {
        "text": "our SIMD intersection procedure is clearly superior to the scalar galloping, being up to twice as fast.",
        "box": [
            93,
            217,
            500,
            227
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 783,
        "relation": "connect"
    },
    {
        "text": "As the ratio increases, reflecting a greater difference in list sizes, non-SIMD galloping eventually",
        "box": [
            93,
            229,
            500,
            239
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 784,
        "relation": "connect"
    },
    {
        "text": "becomes nearly as fast as our SIMD intersection. We also compare with Katsov\u2019s algorithm (see",
        "box": [
            93,
            241,
            500,
            251
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 785,
        "relation": "connect"
    },
    {
        "text": "Fig. 7b). Katsov is only competitive with our algorithms when the lists have similar lengths.",
        "box": [
            93,
            253,
            470,
            263
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 786,
        "relation": "connect"
    },
    {
        "text": "We also included our versions of Schlegel et al.\u2019s algorithm: the original and an improved version",
        "box": [
            103,
            265,
            500,
            275
        ],
        "class": "fstline",
        "page": 21,
        "is_meta": false,
        "parent_id": 772,
        "relation": "equality"
    },
    {
        "text": "relying on the pcmpistrm instruction (see Fig. 7c). In these particular tests, the 32-bit integers are",
        "box": [
            93,
            276,
            500,
            287
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 788,
        "relation": "connect"
    },
    {
        "text": "first transformed into Schlegel et al.\u2019s specialized data structure, as several arrays of 16-bit integers.",
        "box": [
            93,
            289,
            500,
            299
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 789,
        "relation": "connect"
    },
    {
        "text": "We also output the answer in this format. The improved version of Schlegel et al.\u2019s algorithm is about",
        "box": [
            93,
            301,
            500,
            311
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 790,
        "relation": "connect"
    },
    {
        "text": "15 % faster, in the best case. This supports our claim that the pcmpistrm instruction is preferable",
        "box": [
            93,
            312,
            500,
            323
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 791,
        "relation": "connect"
    },
    {
        "text": "to the pcmpestrm instruction. We compared Schlegel et al. with a version of V1 adapted to lists",
        "box": [
            93,
            324,
            500,
            335
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 792,
        "relation": "connect"
    },
    {
        "text": "of 16-bit integers. Like the 32-bit V1, the 16-bit V1 compares blocks of 256 bits and thus compares",
        "box": [
            93,
            336,
            500,
            347
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 793,
        "relation": "connect"
    },
    {
        "text": "sixteen pairs of 16-bit integers at a time (i.e., T = 16). We find that Schlegel et al. is better than V1",
        "box": [
            93,
            348,
            499,
            359
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 794,
        "relation": "connect"
    },
    {
        "text": "as long as the ratio of lengths is less than 10. When one list is much longer than the other one, V1",
        "box": [
            93,
            360,
            499,
            371
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 795,
        "relation": "connect"
    },
    {
        "text": "becomes much faster (up to 75\u00d7 faster in this test). We do not use Schlegel et al.\u2019s 16-bit format",
        "box": [
            93,
            372,
            500,
            383
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 796,
        "relation": "connect"
    },
    {
        "text": "further, but our results suggest that we could combine V 1 and Schlegel et al.\u2019s algorithm for best",
        "box": [
            93,
            384,
            500,
            395
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 797,
        "relation": "connect"
    },
    {
        "text": "results. That is, we could use Schlegel et al. for lists having similar lengths, and V1 otherwise.",
        "box": [
            93,
            396,
            480,
            406
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 798,
        "relation": "connect"
    },
    {
        "text": "We also evaluated our algorithms using postings lists for our three collections using our TREC 1M",
        "box": [
            103,
            408,
            500,
            418
        ],
        "class": "fstline",
        "page": 21,
        "is_meta": false,
        "parent_id": 788,
        "relation": "equality"
    },
    {
        "text": "Query log (see Table VI and Fig. 8). For this test, posting lists are uncompressed. We see that our",
        "box": [
            93,
            420,
            500,
            430
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 800,
        "relation": "connect"
    },
    {
        "text": "SIMD intersection routine is nearly twice as fast as (non-SIMD) galloping. In the sorted version",
        "box": [
            93,
            432,
            500,
            442
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 801,
        "relation": "connect"
    },
    {
        "text": "of Gov2, we expect most gaps between document identifiers to be small, with a few large gaps. In",
        "box": [
            93,
            444,
            500,
            454
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 802,
        "relation": "connect"
    },
    {
        "text": "contrast, the unsorted version of Gov2 has a more uniform distribution of gaps. Just as we find that",
        "box": [
            93,
            456,
            500,
            466
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 803,
        "relation": "connect"
    },
    {
        "text": "intersections are faster on the ClusterData distributions, we find that intersections are 1.4\u20132\u00d7 faster",
        "box": [
            93,
            468,
            500,
            478
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 804,
        "relation": "connect"
    },
    {
        "text": "on the sorted Gov2 vs. its unsorted counterpart. In the next section (\u00a7 7.7), we show that a much",
        "box": [
            93,
            480,
            500,
            490
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 805,
        "relation": "connect"
    },
    {
        "text": "better speed is possible if we use bitmaps to represent some posting lists.",
        "box": [
            93,
            492,
            392,
            502
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 806,
        "relation": "connect"
    },
    {
        "text": "7.7. Bitmap-list hybrids (HY B + M 2)",
        "box": [
            93,
            515,
            241,
            526
        ],
        "class": "sec2",
        "page": 21,
        "is_meta": false,
        "parent_id": 754,
        "relation": "equality"
    },
    {
        "text": "We can also use bitmaps to accelerate intersections. Culpepper and Moffat\u2019s H YB+ M2 framework",
        "box": [
            93,
            534,
            500,
            544
        ],
        "class": "fstline",
        "page": 21,
        "is_meta": false,
        "parent_id": 808,
        "relation": "contain"
    },
    {
        "text": "is simple but effective [5]: all lists where the average gap size is smaller or equal to B (where",
        "box": [
            93,
            546,
            500,
            556
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 809,
        "relation": "connect"
    },
    {
        "text": "B = 8, 16 or 32) are stored as bitmaps whereas other lists are stored as compressed deltas (using",
        "box": [
            93,
            557,
            500,
            568
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 810,
        "relation": "connect"
    },
    {
        "text": "VARIN T or another compression algorithm). To compute any intersection, the compressed lists are",
        "box": [
            93,
            569,
            500,
            580
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 811,
        "relation": "connect"
    },
    {
        "text": "first intersected (e.g., using galloping) and the result is then checked against the bitmaps one by one.",
        "box": [
            93,
            581,
            500,
            592
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 812,
        "relation": "connect"
    },
    {
        "text": "It is a hybrid approach in the sense that it uses both bitmaps and compressed deltas. We modify",
        "box": [
            93,
            593,
            500,
            604
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 813,
        "relation": "connect"
    },
    {
        "text": "their framework by replacing the compression and intersection functions with SIMD-based ones.",
        "box": [
            93,
            605,
            500,
            616
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 814,
        "relation": "connect"
    },
    {
        "text": "To simplify our analysis, we use galloping intersections with scalar compression schemes such as",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 815,
        "relation": "connect"
    },
    {
        "text": "VARIN T and FA S TPF O R , and SIMD intersections with SIMD compression schemes. Intersections",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 816,
        "relation": "connect"
    },
    {
        "text": "between lists are always computed over uncompressed lists. SIMD intersections are computed using",
        "box": [
            93,
            641,
            500,
            651
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 817,
        "relation": "connect"
    },
    {
        "text": "the hybrid made of V 1, V3 and SI M D GAL LO P IN G presented in \u00a7 6.2.1.",
        "box": [
            93,
            653,
            395,
            663
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 818,
        "relation": "connect"
    },
    {
        "text": "To improve data cache utilization, we split our corpora into parts processed separately (32 parts",
        "box": [
            103,
            665,
            500,
            675
        ],
        "class": "fstline",
        "page": 21,
        "is_meta": false,
        "parent_id": 809,
        "relation": "equality"
    },
    {
        "text": "for GOV2 and 64 parts for ClueWeb09). The partition is based on document identifiers: we have,",
        "box": [
            93,
            677,
            500,
            687
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 820,
        "relation": "connect"
    },
    {
        "text": "effectively, 32 or 64 independent indexes that apply to different document subsets. Thus, all",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 821,
        "relation": "connect"
    },
    {
        "text": "intermediate results for a single part can fit into L3 cache. Given a query, we first obtain the result for",
        "box": [
            93,
            701,
            500,
            711
        ],
        "class": "para",
        "page": 21,
        "is_meta": false,
        "parent_id": 822,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "fstline",
        "page": 22,
        "is_meta": false,
        "parent_id": 820,
        "relation": "equality"
    },
    {
        "text": "23",
        "box": [
            489,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 22,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "0.1110100 1 4 16 64 256 1024 4096relativespeed(scalar=1) Ratio length (large list) / length(small list)SIMD V1SIMD V3SIMD Galloping 0.1110100 1 4 16 64 256 1024 4096relativespeed(scalar=1) Ratio length (large list) / length(small list)SIMD V1SIMD V3SIMD Galloping(a) SIMD V1 vs. SIMD V3 vs. SIMD Galloping (m/3 left, 0.01m right)0.51248163264 1 4 16 64 256 1024 4096relativespeed(scalar=1) Ratio length (large list) / length(small list)gallopingSIMD (V1+V3+gal.) 0.512481632 1 4 16 64 256 1024 4096relativespeed(scalar=1) Ratio length (large list) / length(small list)gallopingSIMD (V1+V3+gal.)Katsov(b) SIMD vs. non-SIMD galloping Intersection vs. Katsov (m/3 left, 0.01m right)0.51248163264128 1 4 16 64 256 1024 4096speed(16-bitscalar=1) Ratio length (large list) / length(small list)Schlegel et al. (improved)Schlegel et al. (original)16-bit SIMD V1 0.51248163264128 1 4 16 64 256 1024 4096speed(16-bitscalar=1) Ratio length (large list) / length(small list)Schlegel et al. (improved)Schlegel et al. (original)16-bit SIMD V1(c) 16-bit case (m/3 left, 0.01m right)",
        "box": [
            94,
            62,
            487,
            490
        ],
        "class": "fig",
        "page": 22,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Figure 7. Intersection between two lists of different cardinality as described in \u00a7 7.6. We provide both the",
        "box": [
            93,
            495,
            500,
            505
        ],
        "class": "figcap",
        "page": 22,
        "is_meta": false,
        "parent_id": 826,
        "relation": "contain"
    },
    {
        "text": "case where the size of the intersection is m/3 and where the size of the intersection is 0.01m.",
        "box": [
            120,
            505,
            473,
            515
        ],
        "class": "opara",
        "page": 22,
        "is_meta": false,
        "parent_id": 827,
        "relation": "connect"
    },
    {
        "text": "the first part, then for the second, and so on. Finally, all partial results are collected in one array. In",
        "box": [
            93,
            546,
            500,
            556
        ],
        "class": "para",
        "page": 22,
        "is_meta": false,
        "parent_id": 824,
        "relation": "connect"
    },
    {
        "text": "each part, we work directly on compressed lists and bitmaps, without other auxiliary data structures.",
        "box": [
            93,
            557,
            500,
            568
        ],
        "class": "para",
        "page": 22,
        "is_meta": false,
        "parent_id": 829,
        "relation": "connect"
    },
    {
        "text": "The lists are decompressed and then intersected. We expect our approach to be reasonably efficient",
        "box": [
            93,
            569,
            500,
            580
        ],
        "class": "para",
        "page": 22,
        "is_meta": false,
        "parent_id": 830,
        "relation": "connect"
    },
    {
        "text": "given our benchmark: in Appendix B, we validate it against an alternative that involves skipping.",
        "box": [
            93,
            581,
            490,
            592
        ],
        "class": "para",
        "page": 22,
        "is_meta": false,
        "parent_id": 831,
        "relation": "connect"
    },
    {
        "text": "As shown in Table VII and Fig. 9, the schemes using SIMD instructions are 2\u20133 times faster than",
        "box": [
            103,
            593,
            500,
            604
        ],
        "class": "fstline",
        "page": 22,
        "is_meta": false,
        "parent_id": 824,
        "relation": "equality"
    },
    {
        "text": "FAST PFOR and VARI N T while having comparable compression ratios. The retrieval times can be",
        "box": [
            93,
            605,
            500,
            616
        ],
        "class": "para",
        "page": 22,
        "is_meta": false,
        "parent_id": 833,
        "relation": "connect"
    },
    {
        "text": "improved (up to \u2248 4\u00d7) with the addition of bitmaps, but the index is sometimes larger (up to \u2248 2\u00d7).",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "para",
        "page": 22,
        "is_meta": false,
        "parent_id": 834,
        "relation": "connect"
    },
    {
        "text": "For B = 8, B = 16, and indices without bitmaps, the various S 4 - B P1 28- * schemes provide",
        "box": [
            103,
            629,
            500,
            639
        ],
        "class": "fstline",
        "page": 22,
        "is_meta": false,
        "parent_id": 833,
        "relation": "equality"
    },
    {
        "text": "different space vs. performance trade offs. For example, for ClueWeb09 and B = 8, S4 - BP1 2 8-D4",
        "box": [
            93,
            641,
            499,
            651
        ],
        "class": "para",
        "page": 22,
        "is_meta": false,
        "parent_id": 836,
        "relation": "connect"
    },
    {
        "text": "is 11 % faster than S 4 - B P1 28- D 1, but S4 - BP 12 8-D1 uses 7 % less space.",
        "box": [
            93,
            653,
            402,
            663
        ],
        "class": "para",
        "page": 22,
        "is_meta": false,
        "parent_id": 837,
        "relation": "connect"
    },
    {
        "text": "We also compare scalar vs. SIMD-based algorithms. For ClueWeb09, S4 - FA S TPF O R - D 1 can be",
        "box": [
            103,
            665,
            500,
            675
        ],
        "class": "fstline",
        "page": 22,
        "is_meta": false,
        "parent_id": 836,
        "relation": "equality"
    },
    {
        "text": "nearly twice as fast as the non-SIMD FA S TPF O R scheme (see Fig. 10). Even with B = 16 where",
        "box": [
            93,
            677,
            500,
            687
        ],
        "class": "para",
        "page": 22,
        "is_meta": false,
        "parent_id": 839,
        "relation": "connect"
    },
    {
        "text": "we rely more on the bitmaps for speed, S4 - FA S TPF O R is over 50 % faster than FA S T P F O R (for",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "para",
        "page": 22,
        "is_meta": false,
        "parent_id": 840,
        "relation": "connect"
    },
    {
        "text": "ClueWeb09). As expected, for B = 32, there is virtually no difference in speed and compression",
        "box": [
            93,
            701,
            500,
            711
        ],
        "class": "fstline",
        "page": 22,
        "is_meta": false,
        "parent_id": 839,
        "relation": "equality"
    },
    {
        "text": "24",
        "box": [
            93,
            38,
            103,
            49
        ],
        "class": "header",
        "page": 23,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "fstline",
        "page": 23,
        "is_meta": false,
        "parent_id": 842,
        "relation": "equality"
    },
    {
        "text": "00.511.522.53 GOV2 (sorted) GOV2 (unsorted) ClueWeb09Time(ms/query) SIMD SvS Galloping SvS",
        "box": [
            150,
            63,
            428,
            236
        ],
        "class": "fig",
        "page": 23,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Figure 8. Average time required to answer queries over uncompressed posting lists.",
        "box": [
            139,
            247,
            454,
            256
        ],
        "class": "figcap",
        "page": 23,
        "is_meta": false,
        "parent_id": 845,
        "relation": "contain"
    },
    {
        "text": "ratios among various S4 - B P1 28-* compression schemes. However, S4 - BP12 8-D4 is still about",
        "box": [
            93,
            289,
            500,
            299
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 844,
        "relation": "connect"
    },
    {
        "text": "twice as fast as VARI NT so that, even in this extreme case, our SIMD algorithms are worthwhile.",
        "box": [
            93,
            301,
            488,
            311
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 847,
        "relation": "connect"
    },
    {
        "text": "As a reference point, we also implemented intersections using the Skipper [36] approach. In this",
        "box": [
            103,
            313,
            500,
            323
        ],
        "class": "fstline",
        "page": 23,
        "is_meta": false,
        "parent_id": 844,
        "relation": "equality"
    },
    {
        "text": "last case, posting lists are stored as deltas compressed using VARI NT. However, to support random",
        "box": [
            93,
            325,
            500,
            335
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 849,
        "relation": "connect"
    },
    {
        "text": "access, we have an auxiliary data structure containing sampled uncompressed values with pointers",
        "box": [
            93,
            337,
            500,
            347
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 850,
        "relation": "connect"
    },
    {
        "text": "inside the array of compressed deltas. We found that sampling every 32 integers gave good results.",
        "box": [
            93,
            349,
            500,
            359
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 851,
        "relation": "connect"
    },
    {
        "text": "Because we need to store both the uncompressed integer and a pointer for each 32 integers, the",
        "box": [
            93,
            360,
            500,
            371
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 852,
        "relation": "connect"
    },
    {
        "text": "auxiliary Skipper data structure adds about two bits of storage per integer. We refer to the original",
        "box": [
            93,
            372,
            500,
            383
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 853,
        "relation": "connect"
    },
    {
        "text": "paper and to our software for details. We find that Skipper was 2 to 3 times faster than intersections",
        "box": [
            93,
            384,
            500,
            395
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 854,
        "relation": "connect"
    },
    {
        "text": "over VA R I NT -compressed deltas (at the expense of storage) without bitmap, but compared with the",
        "box": [
            93,
            396,
            500,
            407
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 855,
        "relation": "connect"
    },
    {
        "text": "H YB+M2 framework (B = 8, 16, 32) or our SIMD-based approaches, it is not competitive. Though",
        "box": [
            93,
            408,
            500,
            419
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 856,
        "relation": "connect"
    },
    {
        "text": "we could replace VA R I NT in Skipper by a faster alternative, we expect that the benefits of skipping",
        "box": [
            93,
            420,
            500,
            430
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 857,
        "relation": "connect"
    },
    {
        "text": "would then be diminished.",
        "box": [
            93,
            432,
            202,
            442
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 858,
        "relation": "connect"
    },
    {
        "text": "We also recorded the median and the 90th percentile retrieval times. All these metrics benefited",
        "box": [
            103,
            443,
            500,
            454
        ],
        "class": "fstline",
        "page": 23,
        "is_meta": false,
        "parent_id": 849,
        "relation": "equality"
    },
    {
        "text": "from our techniques. Moreover, our measures are accurate: after repeating experiments five times,",
        "box": [
            93,
            456,
            500,
            466
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 860,
        "relation": "connect"
    },
    {
        "text": "we find that all standard deviations are less than 1 %.",
        "box": [
            93,
            468,
            310,
            478
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 861,
        "relation": "connect"
    },
    {
        "text": "8. DISCUSSION AND CONCLUSIONS",
        "box": [
            210,
            522,
            383,
            532
        ],
        "class": "sec1",
        "page": 23,
        "is_meta": false,
        "parent_id": 608,
        "relation": "equality"
    },
    {
        "text": "We demonstrated that combining unpacking and differential coding resulted in faster decompression",
        "box": [
            93,
            546,
            500,
            556
        ],
        "class": "fstline",
        "page": 23,
        "is_meta": false,
        "parent_id": 863,
        "relation": "contain"
    },
    {
        "text": "speeds, which were approximately 30 % better than the best speeds reported previously [3]. To match",
        "box": [
            93,
            557,
            500,
            568
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 864,
        "relation": "connect"
    },
    {
        "text": "the performance of these fast compression schemes, we additionally vectorized and optimized the",
        "box": [
            93,
            569,
            500,
            580
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 865,
        "relation": "connect"
    },
    {
        "text": "intersection of posting lists. To this end, we introduced a family of algorithms exploiting commonly",
        "box": [
            93,
            581,
            500,
            592
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 866,
        "relation": "connect"
    },
    {
        "text": "available SIMD instructions (V 1, V 3 and S I MD G AL LO P IN G). They are often twice as fast as the",
        "box": [
            93,
            593,
            500,
            604
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 867,
        "relation": "connect"
    },
    {
        "text": "best non-SIMD algorithms. Then, we used our fast SIMD routines for decompression and posting",
        "box": [
            93,
            605,
            500,
            616
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 868,
        "relation": "connect"
    },
    {
        "text": "intersection to accelerate Culpepper and Moffat\u2019s HYB+ M 2 [5]. We believe that HY B +M 2 is one of",
        "box": [
            93,
            617,
            500,
            628
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 869,
        "relation": "connect"
    },
    {
        "text": "the fastest published algorithms for conjunctive queries. Yet we were able to sometimes double the",
        "box": [
            93,
            629,
            500,
            639
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 870,
        "relation": "connect"
    },
    {
        "text": "speed of H YB+M2 without sacrificing compression.",
        "box": [
            93,
            641,
            305,
            651
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 871,
        "relation": "connect"
    },
    {
        "text": "Our work was focused on 128-bit vectors. Intel and AMD recently released processors that",
        "box": [
            103,
            653,
            500,
            663
        ],
        "class": "fstline",
        "page": 23,
        "is_meta": false,
        "parent_id": 864,
        "relation": "equality"
    },
    {
        "text": "support integer operations on 256-bit vectors using the new AVX2 instruction set. On such a",
        "box": [
            93,
            665,
            500,
            675
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 873,
        "relation": "connect"
    },
    {
        "text": "processor, Willhalm et al. [37] were able to double their bit unpacking speed. Moreover, Intel plans",
        "box": [
            93,
            677,
            500,
            687
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 874,
        "relation": "connect"
    },
    {
        "text": "to support 512-bit vectors in 2015 on its commodity processors. Thus optimizing algorithms for",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 875,
        "relation": "connect"
    },
    {
        "text": "SIMD instructions will become even more important in the near future.",
        "box": [
            93,
            701,
            385,
            711
        ],
        "class": "para",
        "page": 23,
        "is_meta": false,
        "parent_id": 876,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "fstline",
        "page": 24,
        "is_meta": false,
        "parent_id": 873,
        "relation": "equality"
    },
    {
        "text": "25",
        "box": [
            489,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 24,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "0123456789 2 3 4 5 6 7 8 9averagequerytime(ms) bits / int VARIN TFastPFORS4-BP1 28 - D4S4-BP1 28 - DMS4-BP1 28 - D2S4-BP1 28 - D1S4-Fas tPFOR(a) GOV2 (unsorted)0123456789 2 3 4 5 6 7 8 9averagequerytime(ms) bits / int VARIN TFastPFORS4-BP1 28 - D4S4-BP1 28 - DMS4-BP1 28 - D2S4-BP1 28 - D1S4-Fas tPFOR(b) G OV 2 (sorted)05101520 4 5 6 7 8 9averagequerytime(ms) bits/int VARIN TFastPFORS4-BP1 28 - D4S4-BP1 28 - DMS4-BP1 28 - D2S4-BP1 28 - D1S4-Fas tPFOR(c) CLUE WE B 09",
        "box": [
            153,
            68,
            445,
            641
        ],
        "class": "fig",
        "page": 24,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Figure 9. Average time required to answer queries vs. the storage requirement in bits/int without bitmap",
        "box": [
            99,
            649,
            491,
            658
        ],
        "class": "figcap",
        "page": 24,
        "is_meta": false,
        "parent_id": 880,
        "relation": "contain"
    },
    {
        "text": "REFERENCES",
        "box": [
            270,
            693,
            323,
            702
        ],
        "class": "sec1",
        "page": 24,
        "is_meta": false,
        "parent_id": 863,
        "relation": "equality"
    },
    {
        "text": "26",
        "box": [
            93,
            38,
            103,
            49
        ],
        "class": "header",
        "page": 25,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 882,
        "relation": "contain"
    },
    {
        "text": "012345678910 4 5 6 7 8 9averagequerytime(ms) bits/int8 16 32 VARIN T8 16 32 FastPFOR8 1 6 32 S4-BP1 28 - D18 16 32 S4-Fas tPFOR",
        "box": [
            148,
            68,
            436,
            240
        ],
        "class": "fig",
        "page": 25,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "Figure 10. Average time required to answer queries vs. the storage requirement in bits/int using partitions",
        "box": [
            93,
            247,
            500,
            256
        ],
        "class": "figcap",
        "page": 25,
        "is_meta": false,
        "parent_id": 885,
        "relation": "contain"
    },
    {
        "text": "and various bitmap parameters (B = 8, 16, 32) for CLUEW E B0 9 .",
        "box": [
            173,
            257,
            420,
            266
        ],
        "class": "opara",
        "page": 25,
        "is_meta": false,
        "parent_id": 886,
        "relation": "connect"
    },
    {
        "text": "1. Catena M, Macdonald C, Ounis I. On inverted index compression for search engine efficiency. Advances in",
        "box": [
            101,
            308,
            500,
            316
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 884,
        "relation": "equality"
    },
    {
        "text": "Information Retrieval, Lecture Notes in Computer Science, vol. 8416. Springer International Publishing, 2014;",
        "box": [
            112,
            317,
            500,
            325
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 888,
        "relation": "connect"
    },
    {
        "text": "359\u2013371, doi:10.1007/978- 3-319-06028- 6 30.",
        "box": [
            112,
            326,
            271,
            334
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 889,
        "relation": "connect"
    },
    {
        "text": "2. B \u00a8uttcher S, Clarke CLA. Index compression is good, especially for random access. Proceedings of the 16th ACM",
        "box": [
            101,
            335,
            500,
            343
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 888,
        "relation": "equality"
    },
    {
        "text": "conference on Information and Knowledge Management, CIKM \u201907, ACM: New York, NY, USA, 2007; 761\u2013770,",
        "box": [
            112,
            344,
            500,
            352
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 891,
        "relation": "connect"
    },
    {
        "text": "doi:10.1145/1321440.1321546.",
        "box": [
            112,
            353,
            218,
            361
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 892,
        "relation": "connect"
    },
    {
        "text": "3. Lemire D, Boytsov L. Decoding billions of integers per second through vectorization. Softw. Pract. Exper. 2015;",
        "box": [
            101,
            361,
            500,
            370
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 891,
        "relation": "equality"
    },
    {
        "text": "45(1):1\u201329, doi:10.1002/spe.2203.",
        "box": [
            112,
            371,
            229,
            379
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 894,
        "relation": "connect"
    },
    {
        "text": "4. Ladner RE, Fischer MJ. Parallel prefix computation. J. ACM Oct 1980; 27(4):831\u2013838, doi:10.1145/322217.",
        "box": [
            101,
            379,
            500,
            388
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 894,
        "relation": "equality"
    },
    {
        "text": "322232.",
        "box": [
            112,
            389,
            139,
            397
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 896,
        "relation": "connect"
    },
    {
        "text": "5. Culpepper JS, Moffat A. Efficient set intersection for inverted indexing. ACM Trans. Inf. Syst. Dec 2010; 29(1):1:1\u2013",
        "box": [
            101,
            397,
            500,
            406
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 896,
        "relation": "equality"
    },
    {
        "text": "1:25, doi:10.1145/1877766.1877767.",
        "box": [
            112,
            406,
            238,
            415
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 898,
        "relation": "connect"
    },
    {
        "text": "6. Tatikonda S, Cambazoglu BB, Junqueira FP. Posting list intersection on multicore architectures. Proceedings of",
        "box": [
            101,
            415,
            500,
            424
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 898,
        "relation": "equality"
    },
    {
        "text": "the 34th international ACM SIGIR conference on Research and development in Information Retrieval, SIGIR \u201911,",
        "box": [
            112,
            424,
            500,
            433
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 900,
        "relation": "connect"
    },
    {
        "text": "ACM: New York, NY, USA, 2011; 963\u2013972, doi:10.1145/2009916.2010045.",
        "box": [
            112,
            433,
            372,
            442
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 901,
        "relation": "connect"
    },
    {
        "text": "7. Kim Y, Seo J, Croft WB. Automatic boolean query suggestion for professional search. Proceedings of the 34th",
        "box": [
            101,
            442,
            500,
            451
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 900,
        "relation": "equality"
    },
    {
        "text": "International ACM SIGIR Conference on Research and Development in Information Retrieval, SIGIR \u201911, ACM:",
        "box": [
            112,
            451,
            500,
            460
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 903,
        "relation": "connect"
    },
    {
        "text": "New York, NY, USA, 2011; 825\u2013834, doi:10.1145/2009916.2010026.",
        "box": [
            112,
            460,
            349,
            469
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 904,
        "relation": "connect"
    },
    {
        "text": "8. Stepanov AA, Gangolli AR, Rose DE, Ernst RJ, Oberoi PS. SIMD-based decoding of posting lists. Proceedings",
        "box": [
            101,
            469,
            500,
            478
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 903,
        "relation": "equality"
    },
    {
        "text": "of the 20th ACM International Conference on Information and Knowledge Management, CIKM \u201911, ACM: New",
        "box": [
            112,
            478,
            500,
            487
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 906,
        "relation": "connect"
    },
    {
        "text": "York, NY, USA, 2011; 317\u2013326, doi:10.1145/2063576.2063627.",
        "box": [
            112,
            487,
            331,
            496
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 907,
        "relation": "connect"
    },
    {
        "text": "9. Ding B, K \u00a8onig AC. Fast set intersection in memory. Proc. VLDB Endow. 2011; 4(4):255\u2013266.",
        "box": [
            101,
            496,
            430,
            505
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 906,
        "relation": "equality"
    },
    {
        "text": "10. Transier F, Sanders P. Engineering basic algorithms of an in-memory text search engine. ACM Trans. Inf. Syst. Dec",
        "box": [
            97,
            505,
            500,
            514
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 909,
        "relation": "equality"
    },
    {
        "text": "2010; 29(1):2:1\u20132:37, doi:10.1145/1877766.1877768.",
        "box": [
            112,
            514,
            295,
            523
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 910,
        "relation": "connect"
    },
    {
        "text": "11. Moffat A, Zobel J. Self-indexing inverted files for fast text retrieval. ACM Trans. Inf. Syst. 1996; 14(4):349\u2013379.",
        "box": [
            97,
            523,
            492,
            531
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 910,
        "relation": "equality"
    },
    {
        "text": "12. Baeza-Yates R. A fast set intersection algorithm for sorted sequences. Combinatorial Pattern Matching, LNCS, vol.",
        "box": [
            97,
            532,
            500,
            540
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 912,
        "relation": "equality"
    },
    {
        "text": "3109, Sahinalp S, Muthukrishnan S, Dogrusoz U (eds.). Springer Berlin / Heidelberg, 2004; 400\u2013408.",
        "box": [
            112,
            541,
            457,
            549
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 913,
        "relation": "connect"
    },
    {
        "text": "13. Demaine ED, L \u00b4opez-Ortiz A, Munro JI. Adaptive set intersections, unions, and differences. Proceedings of the",
        "box": [
            97,
            550,
            500,
            558
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 913,
        "relation": "equality"
    },
    {
        "text": "Eleventh Annual ACM-SIAM Symposium on Discrete Algorithms, SODA \u201900, Society for Industrial and Applied",
        "box": [
            112,
            559,
            500,
            567
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 915,
        "relation": "connect"
    },
    {
        "text": "Mathematics: Philadelphia, PA, USA, 2000; 743\u2013752.",
        "box": [
            112,
            568,
            295,
            576
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 916,
        "relation": "connect"
    },
    {
        "text": "14. Barbay J, L \u00b4opez-Ortiz A, Lu T, Salinger A. An experimental investigation of set intersection algorithms for text",
        "box": [
            97,
            577,
            500,
            585
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 915,
        "relation": "equality"
    },
    {
        "text": "searching. J. Exp. Algorithmics Jan 2010; 14:7:3.7\u20137:3.24, doi:10.1145/1498698.1564507.",
        "box": [
            112,
            586,
            419,
            594
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 918,
        "relation": "connect"
    },
    {
        "text": "15. Kane A, Tompa F. Skewed partial bitvectors for list intersection. Proceedings of the 37th annual international ACM",
        "box": [
            97,
            595,
            500,
            603
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 918,
        "relation": "equality"
    },
    {
        "text": "SIGIR conference on Research and development in information retrieval, ACM, 2014; 263\u2013272.",
        "box": [
            112,
            604,
            438,
            612
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 920,
        "relation": "connect"
    },
    {
        "text": "16. Ding S, He J, Yan H, Suel T. Using graphics processors for high performance IR query processing. Proceedings",
        "box": [
            97,
            612,
            500,
            621
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 920,
        "relation": "equality"
    },
    {
        "text": "of the 18th international conference on World wide web, WWW \u201909, ACM: New York, NY, USA, 2009; 421\u2013430,",
        "box": [
            112,
            621,
            500,
            630
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 922,
        "relation": "connect"
    },
    {
        "text": "doi:10.1145/1526709.1526766.",
        "box": [
            112,
            631,
            218,
            639
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 923,
        "relation": "connect"
    },
    {
        "text": "17. Ao N, Zhang F, Wu D, Stones DS, Wang G, Liu X, Liu J, Lin S. Efficient parallel lists intersection and index",
        "box": [
            97,
            640,
            500,
            648
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 922,
        "relation": "equality"
    },
    {
        "text": "compression algorithms using graphics processing units. Proc. VLDB Endow. May 2011; 4(8):470\u2013481.",
        "box": [
            112,
            648,
            463,
            657
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 925,
        "relation": "connect"
    },
    {
        "text": "18. Konow R, Navarro G, Clarke CL, L \u00b4opez-Ort\u00b4\u0131z A. Faster and smaller inverted indices with treaps. Proceedings of",
        "box": [
            97,
            657,
            500,
            666
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 925,
        "relation": "equality"
    },
    {
        "text": "the 36th International ACM SIGIR Conference on Research and Development in Information Retrieval, SIGIR \u201913,",
        "box": [
            112,
            666,
            500,
            675
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 927,
        "relation": "connect"
    },
    {
        "text": "ACM: New York, NY, USA, 2013; 193\u2013202, doi:10.1145/2484028.2484088.",
        "box": [
            112,
            675,
            372,
            684
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 928,
        "relation": "connect"
    },
    {
        "text": "19. Vigna S. Quasi-succinct indices. Proceedings of the Sixth ACM International Conference on Web Search and Data",
        "box": [
            97,
            684,
            500,
            693
        ],
        "class": "fstline",
        "page": 25,
        "is_meta": false,
        "parent_id": 927,
        "relation": "equality"
    },
    {
        "text": "Mining, WSDM \u201913, ACM: New York, NY, USA, 2013; 83\u201392.",
        "box": [
            112,
            693,
            328,
            702
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 930,
        "relation": "connect"
    },
    {
        "text": "20. Ottaviano G, Venturini R. Partitioned Elias-Fano indexes. SIGIR \u201914, ACM Press: New York, NY, USA, 2014.",
        "box": [
            97,
            702,
            485,
            711
        ],
        "class": "para",
        "page": 25,
        "is_meta": false,
        "parent_id": 931,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 26,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "27",
        "box": [
            489,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 26,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Table VII. Time required to answer queries from TREC 1MQ in ms/query along with the storage requirement",
        "box": [
            93,
            66,
            500,
            75
        ],
        "class": "tabcap",
        "page": 26,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "in bits/int. Entropies of the deltas are provided. We write S4 -FAS TP F O R as a shorthand for S 4- FA ST PFOR-",
        "box": [
            93,
            76,
            499,
            85
        ],
        "class": "opara",
        "page": 26,
        "is_meta": false,
        "parent_id": 935,
        "relation": "connect"
    },
    {
        "text": "D 1. We omit S4- B P1 2 8 - D M when it does not differ significantly from S 4 -BP128 -D 4 .",
        "box": [
            128,
            86,
            463,
            95
        ],
        "class": "opara",
        "page": 26,
        "is_meta": false,
        "parent_id": 936,
        "relation": "connect"
    },
    {
        "text": "scheme bits/int time bits/int time bits/int timeGOV 2 GOV 2 C LU EW EB0 9(sorted) (unsorted)entropy 1.9 4.6 3.1NO BIT M APVARI NT 8.2 6.3 8.5 8.2 8.2 17.5FA S TP F O R 3.8 6.3 6.2 8.0 5.0 17.3S 4 - B P1 28- D 4 6.2 2.1 7.9 2.5 7.5 5.6S 4 - B P1 28- D M 6.2 2.1 7.7 2.6 7.4 5.7S 4 - B P1 28- D 2 5.6 2.2 7.4 2.6 7.1 6.0S 4 - B P1 28- D 1 5.0 2.4 6.9 2.8 6.6 6.5S 4 - FAS TPF OR 3.8 3.5 6.2 4.0 5.0 9.7B = 8VARI NT 5.8 3.0 7.4 4.7 6.2 9.9FA S TP F O R 4.3 3.0 6.3 4.5 5.2 9.3S 4 - B P1 28- D 4 5.7 1.2 7.4 1.6 6.5 3.4S 4 - B P1 28- D M 5.7 1.2 7.3 1.6 6.4 3.4S 4 - B P1 28- D 2 5.5 1.3 7.1 1.6 6.3 3.6S 4 - B P1 28- D 1 5.3 1.4 6.8 1.7 6.1 3.8S 4 - FAS TPF OR 4.3 1.9 6.3 2.3 5.2 5.4B = 16VARI NT 6.3 2.1 8.2 3.2 6.9 6.7FA S TP F O R 5.5 2.1 7.6 2.9 6.4 5.9S 4 - B P1 28- D 4 6.5 0.9 8.4 1.2 7.2 2.5S 4 - B P1 28- D 2 6.4 1.0 8.1 1.2 7.1 2.6S 4 - B P1 28- D 1 6.2 1.1 7.9 1.3 7.0 2.7S 4 - FAS TPF OR 5.5 1.4 7.6 1.6 6.4 3.7B = 32VARI NT 8.2 1.4 11.1 2.0 8.9 4.2FA S TP F O R 7.8 1.5 10.9 1.8 8.7 3.7S 4 - B P1 28- D 4 8.4 0.8 11.2 0.9 9.1 1.9S 4 - B P1 28- D 2 8.4 0.8 11.1 1.0 9.1 2.0S 4 - B P1 28- D 1 8.3 0.8 11.0 1.0 9.0 2.0S 4 - FAS TPF OR 7.8 1.1 10.9 1.2 8.7 2.6Skipper [36] 10.2 2.6 10.5 4.3 10.2 7.7",
        "box": [
            171,
            103,
            423,
            562
        ],
        "class": "tab",
        "page": 26,
        "is_meta": false,
        "parent_id": 935,
        "relation": "contain"
    },
    {
        "text": "21. Fog A. Instruction tables: Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel,",
        "box": [
            97,
            586,
            500,
            594
        ],
        "class": "fstline",
        "page": 26,
        "is_meta": false,
        "parent_id": 930,
        "relation": "equality"
    },
    {
        "text": "AMD and VIA CPUs. Technical Report, Copenhagen University College of Engineering 2014. http://www.",
        "box": [
            112,
            594,
            500,
            603
        ],
        "class": "para",
        "page": 26,
        "is_meta": false,
        "parent_id": 939,
        "relation": "connect"
    },
    {
        "text": "agner.org/optimize/instruction_tables.pdf [last checked March 2015].",
        "box": [
            112,
            603,
            415,
            612
        ],
        "class": "para",
        "page": 26,
        "is_meta": false,
        "parent_id": 940,
        "relation": "connect"
    },
    {
        "text": "22. Intel Corporation. The Intel Intrinsics Guide. https://software.intel.com/sites/landingpage/",
        "box": [
            97,
            612,
            500,
            621
        ],
        "class": "para",
        "page": 26,
        "is_meta": false,
        "parent_id": 941,
        "relation": "connect"
    },
    {
        "text": "IntrinsicsGuide/ [last checked March 2015] 2014.",
        "box": [
            112,
            621,
            307,
            630
        ],
        "class": "para",
        "page": 26,
        "is_meta": false,
        "parent_id": 942,
        "relation": "connect"
    },
    {
        "text": "23. Thiel L, Heaps H. Program design for retrospective searches on large data bases. Information Storage and Retrieval",
        "box": [
            97,
            630,
            500,
            639
        ],
        "class": "fstline",
        "page": 26,
        "is_meta": false,
        "parent_id": 939,
        "relation": "equality"
    },
    {
        "text": "1972; 8(1):1\u201320.",
        "box": [
            112,
            640,
            169,
            648
        ],
        "class": "para",
        "page": 26,
        "is_meta": false,
        "parent_id": 944,
        "relation": "connect"
    },
    {
        "text": "24. Goldstein J, Ramakrishnan R, Shaft U. Compressing relations and indexes. Proceedings of the Fourteenth",
        "box": [
            97,
            648,
            500,
            657
        ],
        "class": "fstline",
        "page": 26,
        "is_meta": false,
        "parent_id": 944,
        "relation": "equality"
    },
    {
        "text": "International Conference on Data Engineering, ICDE \u201998, IEEE Computer Society: Washington, DC, USA, 1998;",
        "box": [
            112,
            657,
            500,
            666
        ],
        "class": "para",
        "page": 26,
        "is_meta": false,
        "parent_id": 946,
        "relation": "connect"
    },
    {
        "text": "370\u2013379.",
        "box": [
            112,
            666,
            144,
            675
        ],
        "class": "para",
        "page": 26,
        "is_meta": false,
        "parent_id": 947,
        "relation": "connect"
    },
    {
        "text": "25. Anh VN, Moffat A. Index compression using 64-bit words. Softw. Pract. Exper. 2010; 40(2):131\u2013147, doi:",
        "box": [
            97,
            675,
            500,
            684
        ],
        "class": "fstline",
        "page": 26,
        "is_meta": false,
        "parent_id": 946,
        "relation": "equality"
    },
    {
        "text": "10.1002/spe.v40:2.",
        "box": [
            112,
            684,
            176,
            693
        ],
        "class": "para",
        "page": 26,
        "is_meta": false,
        "parent_id": 949,
        "relation": "connect"
    },
    {
        "text": "26. Zukowski M, Heman S, Nes N, Boncz P. Super-scalar RAM-CPU cache compression. Proceedings of the 22nd",
        "box": [
            97,
            693,
            500,
            702
        ],
        "class": "fstline",
        "page": 26,
        "is_meta": false,
        "parent_id": 949,
        "relation": "equality"
    },
    {
        "text": "International Conference on Data Engineering, ICDE \u201906, IEEE Computer Society: Washington, DC, USA, 2006;",
        "box": [
            112,
            702,
            500,
            711
        ],
        "class": "para",
        "page": 26,
        "is_meta": false,
        "parent_id": 951,
        "relation": "connect"
    },
    {
        "text": "28",
        "box": [
            93,
            38,
            103,
            49
        ],
        "class": "header",
        "page": 27,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "D. LEMIRE, L. BOYTSOV, N. KURZ",
        "box": [
            231,
            38,
            362,
            49
        ],
        "class": "header",
        "page": 27,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "59\u201371, doi:10.1109/ICDE.2006.150.",
        "box": [
            112,
            70,
            236,
            78
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 951,
        "relation": "equality"
    },
    {
        "text": "27. Yan H, Ding S, Suel T. Inverted index compression and query processing with optimized document ordering.",
        "box": [
            97,
            79,
            500,
            87
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 955,
        "relation": "equality"
    },
    {
        "text": "Proceedings of the 18th International Conference on World Wide Web, WWW \u201909, ACM: New York, NY, USA,",
        "box": [
            112,
            87,
            500,
            96
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 956,
        "relation": "connect"
    },
    {
        "text": "2009; 401\u2013410, doi:10.1145/1526709.1526764.",
        "box": [
            112,
            97,
            274,
            105
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 957,
        "relation": "connect"
    },
    {
        "text": "28. Bentley JL, Yao ACC. An almost optimal algorithm for unbounded searching. Inf. Process. Lett. 1976; 5(3):82\u201387.",
        "box": [
            97,
            105,
            500,
            114
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 956,
        "relation": "equality"
    },
    {
        "text": "29. Zhou J, Ross KA. Implementing database operations using SIMD instructions. Proceedings of the 2002 ACM",
        "box": [
            97,
            114,
            500,
            123
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 959,
        "relation": "equality"
    },
    {
        "text": "SIGMOD International Conference on Management of Data, SIGMOD \u201902, ACM: New York, NY, USA, 2002;",
        "box": [
            112,
            123,
            500,
            132
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 960,
        "relation": "connect"
    },
    {
        "text": "145\u2013156, doi:10.1145/564691.564709.",
        "box": [
            112,
            132,
            244,
            141
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 961,
        "relation": "connect"
    },
    {
        "text": "30. Schlegel B, Willhalm T, Lehner W. Fast sorted-set intersection using SIMD instructions. Proceedings of the",
        "box": [
            97,
            141,
            500,
            150
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 960,
        "relation": "equality"
    },
    {
        "text": "2nd International Workshop on Accelerating Data Management Systems Using Modern Processor and Storage",
        "box": [
            112,
            150,
            500,
            159
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 963,
        "relation": "connect"
    },
    {
        "text": "Architectures, ADMS \u201911, 2011; 1\u20138.",
        "box": [
            112,
            159,
            239,
            168
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 964,
        "relation": "connect"
    },
    {
        "text": "31. Katsov I. Fast intersection of sorted lists using SSE instructions. http://highlyscalable.wordpress.",
        "box": [
            97,
            168,
            500,
            177
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 963,
        "relation": "equality"
    },
    {
        "text": "com/2012/06/05/fast- intersection-sorted-lists-sse/ [last checked March 2015] 2009.",
        "box": [
            112,
            177,
            482,
            186
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 966,
        "relation": "connect"
    },
    {
        "text": "32. Balkesen C, Alonso G, Teubner J, \u00a8Ozsu M. Multicore, main-memory joins: Sort vs. hash revisited. Proc. VLDB",
        "box": [
            97,
            184,
            500,
            195
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 966,
        "relation": "equality"
    },
    {
        "text": "Endow. 2013; 7(1):85\u201396.",
        "box": [
            112,
            195,
            200,
            204
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 968,
        "relation": "connect"
    },
    {
        "text": "33. Schlegel B, Gemulla R, Lehner W. k-ary search on modern processors. Proceedings of the Fifth International",
        "box": [
            97,
            204,
            500,
            213
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 968,
        "relation": "equality"
    },
    {
        "text": "Workshop on Data Management on New Hardware, DaMoN \u201909, ACM: New York, NY, USA, 2009; 52\u201360, doi:",
        "box": [
            112,
            213,
            500,
            222
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 970,
        "relation": "connect"
    },
    {
        "text": "10.1145/1565694.1565705.",
        "box": [
            112,
            222,
            205,
            231
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 971,
        "relation": "connect"
    },
    {
        "text": "34. Polychroniou O, Ross KA. Vectorized bloom filters for advanced simd processors. Proceedings of the Tenth",
        "box": [
            97,
            231,
            500,
            240
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 970,
        "relation": "equality"
    },
    {
        "text": "International Workshop on Data Management on New Hardware, DaMoN \u201914, ACM: New York, NY, USA, 2014;",
        "box": [
            112,
            240,
            500,
            249
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 973,
        "relation": "connect"
    },
    {
        "text": "1\u20136, doi:10.1145/2619228.2619234.",
        "box": [
            112,
            249,
            235,
            258
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 974,
        "relation": "connect"
    },
    {
        "text": "35. Tonellotto N, Macdonald C, Ounis I. Effect of different docid orderings on dynamic pruning retrieval strategies.",
        "box": [
            97,
            258,
            500,
            266
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 973,
        "relation": "equality"
    },
    {
        "text": "Proceedings of the 34th International ACM SIGIR Conference on Research and Development in Information",
        "box": [
            112,
            267,
            500,
            275
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 976,
        "relation": "connect"
    },
    {
        "text": "Retrieval, SIGIR \u201911, ACM: New York, NY, USA, 2011; 1179\u20131180, doi:10.1145/2009916.2010108.",
        "box": [
            112,
            276,
            456,
            284
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 977,
        "relation": "connect"
    },
    {
        "text": "36. Sanders P, Transier F. Intersection in integer inverted indices. Proceedings of the 9th Workshop on Algorithm",
        "box": [
            97,
            285,
            500,
            293
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 976,
        "relation": "equality"
    },
    {
        "text": "Engineering and Experiments, ALENEX \u201907, SIAM, 2007; 71\u201383.",
        "box": [
            112,
            294,
            339,
            302
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 979,
        "relation": "connect"
    },
    {
        "text": "37. Willhalm T, Oukid I, M \u00a8uller I, Faerber F. Vectorizing database column scans with complex predicates. Proceedings",
        "box": [
            97,
            303,
            500,
            311
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 979,
        "relation": "equality"
    },
    {
        "text": "of the 4th International Workshop on Accelerating Data Management Systems Using Modern Processor and Storage",
        "box": [
            112,
            312,
            500,
            320
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 981,
        "relation": "connect"
    },
    {
        "text": "Architectures, ADMS \u201913, 2013; 1\u201312.",
        "box": [
            112,
            321,
            243,
            329
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 982,
        "relation": "connect"
    },
    {
        "text": "A. SAMPLE C++ CODE USING INTEL INTRINSICS FOR INTERSECTION ALGORITHMS",
        "box": [
            96,
            355,
            497,
            365
        ],
        "class": "sec1",
        "page": 27,
        "is_meta": false,
        "parent_id": 882,
        "relation": "equality"
    },
    {
        "text": "u i n t 3 2 t * r / / p o i n t e r t o s h o r t l i s t",
        "box": [
            95,
            384,
            312,
            397
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 984,
        "relation": "connect"
    },
    {
        "text": "u i n t 3 2 t * f / / p o i n t e r t o l o n g l i s t",
        "box": [
            95,
            396,
            306,
            409
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 985,
        "relation": "connect"
    },
    {
        "text": "/ / l o a d T = 8 i n t e g e r s f r o m f",
        "box": [
            95,
            420,
            270,
            431
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 986,
        "relation": "connect"
    },
    {
        "text": "m 1 2 8 i F = m m l o a d u s i 1 2 8 ( ( m 1 2 8 i * ) f ) ;",
        "box": [
            104,
            432,
            344,
            445
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 987,
        "relation": "connect"
    },
    {
        "text": "m 1 2 8 i G = m m l o a d u s i 1 2 8 ( ( m 1 2 8 i * ) f + 1 ) ;",
        "box": [
            104,
            444,
            356,
            457
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 988,
        "relation": "connect"
    },
    {
        "text": "/ / r e p l i c a t e c u r r e n t v a l u e f r o m r",
        "box": [
            95,
            468,
            295,
            478
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 989,
        "relation": "connect"
    },
    {
        "text": "m 1 2 8 i R = m m s e t 1 e p i 3 2 ( * r ) ;",
        "box": [
            104,
            480,
            282,
            493
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 990,
        "relation": "connect"
    },
    {
        "text": "/ / c o m p a r e R a n d F , G",
        "box": [
            95,
            504,
            223,
            514
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 991,
        "relation": "connect"
    },
    {
        "text": "m 1 2 8 i T0 = m m c m p e q e p i 3 2 ( F , R ) ;",
        "box": [
            104,
            516,
            307,
            526
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 992,
        "relation": "connect"
    },
    {
        "text": "m 1 2 8 i T1 = m m c m p e q e p i 3 2 ( G , R ) ;",
        "box": [
            104,
            528,
            307,
            538
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 993,
        "relation": "connect"
    },
    {
        "text": "T = m m o r s i 1 2 8 ( T 0 , T1 ) ;",
        "box": [
            93,
            540,
            245,
            550
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 994,
        "relation": "connect"
    },
    {
        "text": "/ *",
        "box": [
            94,
            552,
            104,
            564
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 995,
        "relation": "connect"
    },
    {
        "text": "i f S S E4 i s s u p p o r t e d , we c a n i n s t e a d u s e",
        "box": [
            95,
            564,
            338,
            574
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 996,
        "relation": "connect"
    },
    {
        "text": "a s l i g h t l y f a s t e r i n s t r u c t i o n m m t e s t z s i 1 2 8 ( T , T )",
        "box": [
            94,
            576,
            406,
            586
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 997,
        "relation": "connect"
    },
    {
        "text": "* /",
        "box": [
            94,
            588,
            104,
            600
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 998,
        "relation": "connect"
    },
    {
        "text": "i f ( m m m o v e ma s k e p i 8 ( T ) ! = 0 ) {",
        "box": [
            95,
            600,
            289,
            610
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 999,
        "relation": "connect"
    },
    {
        "text": "/ / o n e v a l u e i n R m a t c h e s a v a l u e i n F , G",
        "box": [
            95,
            612,
            340,
            622
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 1000,
        "relation": "connect"
    },
    {
        "text": "}",
        "box": [
            94,
            624,
            99,
            634
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 1001,
        "relation": "connect"
    },
    {
        "text": "B. BITMAP-LIST HYBRIDS (HYB + M 2) WITH SKIPPING",
        "box": [
            167,
            665,
            425,
            675
        ],
        "class": "sec1",
        "page": 27,
        "is_meta": false,
        "parent_id": 984,
        "relation": "equality"
    },
    {
        "text": "In \u00a7 7.7, we describe experiments using the H YB+M2 model. Short lists are first decompressed",
        "box": [
            93,
            689,
            500,
            699
        ],
        "class": "fstline",
        "page": 27,
        "is_meta": false,
        "parent_id": 1003,
        "relation": "contain"
    },
    {
        "text": "and then intersected (e.g., using the galloping algorithm). As recommended by Culpepper and",
        "box": [
            93,
            701,
            500,
            711
        ],
        "class": "para",
        "page": 27,
        "is_meta": false,
        "parent_id": 1004,
        "relation": "connect"
    },
    {
        "text": "SIMD COMPRESSION AND THE INTERSECTION OF SORTED INTEGERS",
        "box": [
            159,
            38,
            434,
            49
        ],
        "class": "header",
        "page": 28,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "29",
        "box": [
            489,
            38,
            500,
            49
        ],
        "class": "header",
        "page": 28,
        "is_meta": true,
        "parent_id": -1,
        "relation": "meta"
    },
    {
        "text": "Table VIII. Time required to answer queries from TREC 1MQ using bitmaps (HYB +M 2 ) and short lists",
        "box": [
            93,
            66,
            500,
            75
        ],
        "class": "tabcap",
        "page": 28,
        "is_meta": false,
        "parent_id": -1,
        "relation": "contain"
    },
    {
        "text": "compressed with VAR I N T. We compare a skipping approach over short lists using blocks of 32 or 256",
        "box": [
            93,
            76,
            500,
            85
        ],
        "class": "opara",
        "page": 28,
        "is_meta": false,
        "parent_id": 1008,
        "relation": "connect"
    },
    {
        "text": "integers (as in Kane and Tompa [15]) vs. an approach using galloping over partitioned data.",
        "box": [
            122,
            86,
            468,
            95
        ],
        "class": "opara",
        "page": 28,
        "is_meta": false,
        "parent_id": 1009,
        "relation": "connect"
    },
    {
        "text": "GOV2 GOV2 CL UE W EB0 9sorted unsortedB = 8galloping 3.0 4.7 9.9skipping (32) 4.3 7.3 11skipping (256) 4.4 7.5 12B = 16galloping 2.1 3.2 6.7skipping (32) 2.5 4.2 6.4skipping (256) 2.6 4.3 6.9B = 32galloping 1.4 2.0 4.2skipping (32) 1.3 2.1 3.6skipping (256) 1.4 2.1 3.8",
        "box": [
            184,
            102,
            413,
            278
        ],
        "class": "tab",
        "page": 28,
        "is_meta": false,
        "parent_id": 1008,
        "relation": "contain"
    },
    {
        "text": "Moffat [5], we do not use skipping [11]: all integers from the short lists are decompressed. In",
        "box": [
            93,
            301,
            500,
            311
        ],
        "class": "fstline",
        "page": 28,
        "is_meta": false,
        "parent_id": 1004,
        "relation": "equality"
    },
    {
        "text": "contrast, Kane and Tompa [15] found skipping over large blocks in the HY B + M 2 context to be",
        "box": [
            93,
            313,
            500,
            323
        ],
        "class": "para",
        "page": 28,
        "is_meta": false,
        "parent_id": 1012,
        "relation": "connect"
    },
    {
        "text": "highly beneficial. For VARI NT only, we adopt the Kane-Tompa approach, replacing galloping and",
        "box": [
            93,
            325,
            500,
            335
        ],
        "class": "para",
        "page": 28,
        "is_meta": false,
        "parent_id": 1013,
        "relation": "connect"
    },
    {
        "text": "partitions by skipping with blocks of 32 and 256 integers, and present the results in Table VIII using",
        "box": [
            93,
            337,
            500,
            347
        ],
        "class": "para",
        "page": 28,
        "is_meta": false,
        "parent_id": 1014,
        "relation": "connect"
    },
    {
        "text": "the same tests as in \u00a7 7.7. We see that skipping is worse than galloping in most cases (up to 60 %)",
        "box": [
            93,
            348,
            500,
            359
        ],
        "class": "para",
        "page": 28,
        "is_meta": false,
        "parent_id": 1015,
        "relation": "connect"
    },
    {
        "text": "though it can be sometimes be slightly beneficial (up to 15 %). Though these results are only for",
        "box": [
            93,
            360,
            500,
            371
        ],
        "class": "para",
        "page": 28,
        "is_meta": false,
        "parent_id": 1016,
        "relation": "connect"
    },
    {
        "text": "VARIN T compression, we expect the benefits of skipping to be less for faster compression schemes",
        "box": [
            93,
            372,
            500,
            383
        ],
        "class": "para",
        "page": 28,
        "is_meta": false,
        "parent_id": 1017,
        "relation": "connect"
    },
    {
        "text": "such as S 4 - B P1 28-D 4.",
        "box": [
            93,
            384,
            192,
            395
        ],
        "class": "para",
        "page": 28,
        "is_meta": false,
        "parent_id": 1018,
        "relation": "connect"
    }
]